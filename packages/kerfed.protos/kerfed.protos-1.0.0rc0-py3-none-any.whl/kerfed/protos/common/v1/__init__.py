# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: kerfed/protos/common/v1/address.proto, kerfed/protos/common/v1/brand.proto, kerfed/protos/common/v1/combo.proto, kerfed/protos/common/v1/config.proto, kerfed/protos/common/v1/cots.proto, kerfed/protos/common/v1/discount.proto, kerfed/protos/common/v1/error.proto, kerfed/protos/common/v1/fab.proto, kerfed/protos/common/v1/fileblob.proto, kerfed/protos/common/v1/geometry.proto, kerfed/protos/common/v1/machine.proto, kerfed/protos/common/v1/mill.proto, kerfed/protos/common/v1/model.proto, kerfed/protos/common/v1/money.proto, kerfed/protos/common/v1/ndarray.proto, kerfed/protos/common/v1/order.proto, kerfed/protos/common/v1/outcome.proto, kerfed/protos/common/v1/path.proto, kerfed/protos/common/v1/post.proto, kerfed/protos/common/v1/price.proto, kerfed/protos/common/v1/scene.proto, kerfed/protos/common/v1/settings.proto, kerfed/protos/common/v1/shipping.proto, kerfed/protos/common/v1/stock.proto, kerfed/protos/common/v1/timestamp.proto, kerfed/protos/common/v1/tolerance.proto, kerfed/protos/common/v1/tool.proto, kerfed/protos/common/v1/units.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import List

import betterproto


class PostKind(betterproto.Enum):
    """a postprocessing operation: i.e. tapping, welding, etc"""

    POST_KIND_UNSPECIFIED = 0
    """an unspecified postprocessing operation (invalid)"""

    POST_KIND_TAP = 1
    """a tapped hole"""

    POST_KIND_COUNTERSINK = 2
    """a countersunk hole"""

    POST_KIND_COUNTERBORE = 3
    """a counterbored hole"""

    POST_KIND_WELD = 4
    """a welded seam"""

    POST_KIND_BORE = 5
    """a precision reamed or machined hole"""

    POST_KIND_TOLERANCE = 6
    """a tighter than default tolerance"""


class UnitSystem(betterproto.Enum):
    UNIT_SYSTEM_UNSPECIFIED = 0
    """
    If unspecified units in the parent message are assumed to be "meters-
    kilograms-seconds"
    """

    UNIT_SYSTEM_MKS = 1
    """All units in the parent message are `meters-kilograms-seconds`"""

    UNIT_SYSTEM_IPS = 2
    """All units in the parent message are `inches-pounds-seconds`"""


class StockKind(betterproto.Enum):
    STOCK_KIND_UNSPECIFIED = 0
    STOCK_KIND_SHEET = 1
    """A plate or sheet"""

    STOCK_KIND_ROD = 2
    """A rectangular solid"""

    STOCK_KIND_BAR = 3
    """A cylinder."""


class ToolShape(betterproto.Enum):
    TOOL_SHAPE_UNSPECIFIED = 0
    TOOL_SHAPE_SQUARE_MILL = 1
    """A cylinder."""

    TOOL_SHAPE_BALL_MILL = 2
    """A cylinder with a hemispherical end."""

    TOOL_SHAPE_DRILL = 3
    """A drill bit."""


class SegmentTag(betterproto.Enum):
    """The segment's role in the milling process"""

    SEGMENT_TAG_UNSPECIFIED = 0
    """must be explicitly specified."""

    SEGMENT_TAG_CUT = 1
    """
    The segment is cutting material away, probably as a rough cut: this
    generally translates to `G1`
    """

    SEGMENT_TAG_CUT_FINISH = 2
    """
    The segment is doing a finish pass, or the edges of the segment are
    touching the finished part.
    """

    SEGMENT_TAG_CUT_PLUNGE = 3
    """
    The segment is doing a finish pass, or the edges of the segment are
    touching the finished part.
    """

    SEGMENT_TAG_CUT_DRILL = 4
    """This segment represents a drilling operation."""

    SEGMENT_TAG_MOVE = 9
    """
    The segment is a reposition move and is not cutting material away: this
    generall corresponds `G0`
    """

    SEGMENT_TAG_MOVE_SHORTCUT = 10
    """
    This is a shortcut between cutting segments and is not cutting material
    away.
    """

    SEGMENT_TAG_MOVE_LINK = 11
    """
    This is a move where the intermediate region has NOT been checked for
    collision and is relying on a postprocesser to connect or "link" the path.
    A move with this tag MUST be checked before execution and any postprocesser
    should immediately fail if it sees this tag.
    """

    SEGMENT_TAG_ERROR = 15
    """
    Some step in the path generation had an error and we tagged it as an error
    for debugging. The G-code converter should raise an error on this and
    refuse to output a path of any sort.
    """

    SEGMENT_TAG_SENTINEL = 16
    """
    This segment is a "sentinel" used for internal logic and should not be
    included in an output.
    """


class GpuDetail(betterproto.Enum):
    """
    What voxel and toolplane resolution strategy should be used when computing
    milled carving columes.
    """

    GPU_DETAIL_UNSPECIFIED = 0
    """Defaults to STANDARD"""

    GPU_DETAIL_DRAFT = 1
    """Targeted to take less than 1.0 seconds."""

    GPU_DETAIL_STANDARD = 2
    """Targeted to take approximately 2.0 seconds"""

    GPU_DETAIL_HIGH = 3
    """Targeted to take less than 1 minute."""


class FixtureStrategy(betterproto.Enum):
    FIXTURE_STRATEGY_UNSPECIFIED = 0
    """There is no plan, dude."""

    FIXTURE_STRATEGY_VICE = 1
    """There is a pair of parallel edges we can clamp on."""

    FIXTURE_STRATEGY_CHUCK = 2
    """There is a cylindrical surface we can clamp on."""

    FIXTURE_STRATEGY_HOLDDOWN = 3
    """Using a T-slot table and "hold-down" setup clamps."""


@dataclass(eq=False, repr=False)
class PostalAddress(betterproto.Message):
    address_id: str = betterproto.string_field(1)
    """a UUID for this postal address"""

    country: str = betterproto.string_field(2)
    """2-letter ISO3166 alpha-2 country code"""

    region: str = betterproto.string_field(3)
    """in the USA this is a state, i.e. "PA"""

    city: str = betterproto.string_field(4)
    """i.e. "Pittsburgh"""

    postal_code: str = betterproto.string_field(5)
    """in the USA this is a zip code, i.e. "15206"""

    address_lines: List[str] = betterproto.string_field(6)
    """An array of address lines i.e. ['6425 Living Pl.', 'Ste #2121']"""

    recipient: str = betterproto.string_field(7)
    """Who is recieving this package: name, company, etc."""

    phone: str = betterproto.string_field(8)
    """The phone number of the recipient."""

    email: str = betterproto.string_field(9)
    """The email address of the recipient."""

    latitude: float = betterproto.double_field(15)
    """
    Position in degrees on the globe. Optional but if specified may skip a call
    to the Google Places API.
    """

    longitude: float = betterproto.double_field(16)
    place_id: str = betterproto.string_field(17)
    """
    The Google Place ID A place ID is a textual identifier that uniquely
    identifies a place. The length of the identifier may vary (there is no
    maximum length for Place IDs).
    """


@dataclass(eq=False, repr=False)
class FileBlob(betterproto.Message):
    """A file with data."""

    file_id: str = betterproto.string_field(1)
    """
    A unique ID associated with a file that has already been uploaded to
    kerfed.
    """

    name: str = betterproto.string_field(2)
    """
    The filename associated with the file, i.e. "hi.dxf". This can be used when
    downloading the file content to disk. If available, the mediatype should be
    preferred when determining file type.
    """

    data: bytes = betterproto.bytes_field(3)
    """The raw binary data for the file if stored in the message."""

    url: str = betterproto.string_field(4)
    """A URL for the file data if stored remotely."""

    mediatype: str = betterproto.string_field(5)
    """
    The Media Type associated with the file. See:
    https://www.iana.org/assignments/media-types/media-types.xhtml
    """

    sha256: str = betterproto.string_field(6)
    """The SHA 256 hash of the data."""


@dataclass(eq=False, repr=False)
class Brand(betterproto.Message):
    """
    Description of a brand that will be used in generated user-facing materials
    such as drawings and documents.
    """

    brand_id: str = betterproto.string_field(1)
    """The unique uuid key for the brand."""

    name: str = betterproto.string_field(2)
    """The display name for the brand, i.e. "JK Precision Plate"""

    description: str = betterproto.string_field(3)
    """
    A markdown blurb describing the shop: "#JK \n We specialize in plate and
    sheet parts."
    """

    logo: "FileBlob" = betterproto.message_field(4)
    """The logo image for drawings, artifacts, etc."""

    address: "PostalAddress" = betterproto.message_field(5)
    """
    Where is the shop located and contact information including email and phone
    number.
    """

    display_units: str = betterproto.string_field(6)
    """
    What unit system should be displayed? Valid values include {'in', 'meter'},
    etc. A full list of valid unit systems are available with: `import trimesh;
    trimesh.units.keys()`
    """


@dataclass(eq=False, repr=False)
class Combo(betterproto.Message):
    """
    A data structure which implements "aluminum-6061 comes in 0.25" or 0.5"
    thick and can be anodized these three colors" This is translated into the
    front-end inteface dropdown boxes. and should be transmitted to the client-
    side unredacted.
    """

    keys: List[str] = betterproto.string_field(1)
    """
    the combination of config.PartConfiguration keys Note that this is a nested
    data structure and in order to flatten it into a flat list keys alternate:
    `[material_id, steel_hrs, finish_id]` i.e. `material_id`, `finish_id`, etc.
    and thus *only an odd number of keys is valid.*
    """

    values: List[str] = betterproto.string_field(2)
    """
    i.e. `key=['material_id', 'steel_hrs', 'thickness']` then `values=[.0125,
    0.25, 0.5, 1.0, 2.0]`
    """


@dataclass(eq=False, repr=False)
class ComboDescription(betterproto.Message):
    """ """

    config_id: str = betterproto.string_field(1)
    """i.e. 'material_id'"""

    key: str = betterproto.string_field(2)
    """i.e. 'steel_hrs'"""

    label: str = betterproto.string_field(3)
    """a display name for this config key i.e. 'Steel Hot Rolled Sheet'"""

    blurb: str = betterproto.string_field(4)
    """a note about more detail for this config option"""

    color_hex: str = betterproto.string_field(5)
    """a hex string for the color if applicable"""

    link: str = betterproto.string_field(6)
    """a web link for more information"""


@dataclass(eq=False, repr=False)
class Combos(betterproto.Message):
    combos: List["Combo"] = betterproto.message_field(1)
    """allowable configuration options"""

    descriptions: List["ComboDescription"] = betterproto.message_field(2)
    """details about each configuration option"""


@dataclass(eq=False, repr=False)
class PartConfiguration(betterproto.Message):
    method_id: str = betterproto.string_field(1)
    """i.e. 'flat', 'bent', etc"""

    quantity: int = betterproto.uint32_field(2)
    """how many of a part"""

    material_id: str = betterproto.string_field(3)
    """material key, i.e. "aluminum_6061_t6"""

    finish_id: str = betterproto.string_field(4)
    """finish key, i.e. "anodized"""

    color_id: str = betterproto.string_field(5)
    """finish color key, i.e. "blue"""

    thickness_id: str = betterproto.string_field(6)
    """discrete thickness key, i.e. "1.5mm"""

    posts: List[str] = betterproto.string_field(7)
    """selected postprocessing operations i.e. a list of `post_id` keys"""

    expedite: str = betterproto.string_field(8)
    """the expedite kind : standard, rapid, etc"""

    notes: str = betterproto.string_field(9)
    """any notes input by the user"""

    cots_id: str = betterproto.string_field(10)
    """which COTS part was selected from matches"""


@dataclass(eq=False, repr=False)
class Money(betterproto.Message):
    """Represents an amount of money with its currency type."""

    currency: str = betterproto.string_field(1)
    """
    The three-letter currency code defined in ISO-4217. if undefined it is
    assumed to be `USD`
    """

    amount: float = betterproto.double_field(2)
    """
    The amount in `1/100` ("cents/pence") of the specified currency. For
    example, if `currency` is `"USD"`, then 1 unit of amount represents one US
    cent (1/100 dollar). Note that this is a *double* rather than an integer as
    when these messages are serialized to JSON an `int64` would be converted to
    a *string* as JSON does not support large integers. Our APIs will never
    return values here that can't be represented as integers, i.e. it will
    always be a value like `21212.0`
    """


@dataclass(eq=False, repr=False)
class CotsMatch(betterproto.Message):
    """i.e a part number on McMaster-Carr"""

    cots_id: str = betterproto.string_field(1)
    """the unique identifier for the part"""

    supplier_id: str = betterproto.string_field(2)
    """i.e. "mcmaster"""

    link: str = betterproto.string_field(6)
    """a link to the suppliers webpage"""

    title: str = betterproto.string_field(7)
    """A user-displayable label for the part."""

    pack_price: "Money" = betterproto.message_field(8)
    """the price for a PACK of this part."""

    pack_size: int = betterproto.uint32_field(9)
    """the number of this component included in a pack."""

    weight_lb: float = betterproto.double_field(10)
    """the weight of a SINGLE component."""

    component_id: str = betterproto.string_field(11)
    """A component type, like "pin," "bearing", etc."""


@dataclass(eq=False, repr=False)
class Discount(betterproto.Message):
    """Represents an amount of money with its currency type."""

    code: str = betterproto.string_field(1)
    """The discount code used."""

    percent: float = betterproto.double_field(2)
    """
    The percentage of discount. Values outside of the range (0.0, 1.0) will
    throw errors. A value of `0.1` represents a 10% discount or $10.00 off of a
    $100.00 order.
    """


@dataclass(eq=False, repr=False)
class Error(betterproto.Message):
    code: str = betterproto.string_field(1)
    """i.e. "GeometryError"""

    message: str = betterproto.string_field(2)
    """a message that can be shown to the user."""


@dataclass(eq=False, repr=False)
class NdArray(betterproto.Message):
    """* Represent an N dimensional array"""

    shape: List[int] = betterproto.uint32_field(1)
    """what is the shape of this array"""

    float64: List[float] = betterproto.double_field(2)
    """only one should be populated"""

    int64: List[int] = betterproto.int64_field(3)


@dataclass(eq=False, repr=False)
class RigidTransform(betterproto.Message):
    """A homogenous rigid transform"""

    values: List[float] = betterproto.double_field(1)
    """
    should error if there are not exactly 12 values this is skipping the last
    row of [0, 0, 0, 1] and in Python is `transform[:3, :].flatten()`
    """


@dataclass(eq=False, repr=False)
class BilateralTolerance(betterproto.Message):
    value: float = betterproto.float_field(1)
    """the base value in meters, kilograms, seconds"""

    minus: float = betterproto.float_field(2)
    """
    how much under and over *relative* in meters i.e. 0.001" = 2.54e-5 meters
    """

    plus: float = betterproto.float_field(3)


@dataclass(eq=False, repr=False)
class Thread(betterproto.Message):
    is_imperial: bool = betterproto.bool_field(1)
    """
    if imperial mesaurements are in inches otherwise measurements are meters
    """

    description: str = betterproto.string_field(2)
    """1/4-20"""

    pitch: float = betterproto.float_field(3)
    """distance between thread"""

    radius_minor: float = betterproto.float_field(4)
    """minor radius"""

    radius_major: float = betterproto.float_field(5)
    """major radius"""


@dataclass(eq=False, repr=False)
class Countersink(betterproto.Message):
    radius: float = betterproto.float_field(1)
    """maximum radius"""

    angle: float = betterproto.float_field(2)
    """cone angle"""


@dataclass(eq=False, repr=False)
class Counterbore(betterproto.Message):
    radius: float = betterproto.float_field(1)
    """radius of counterbore"""

    depth: float = betterproto.float_field(2)
    """how deep the counterbore goes"""


@dataclass(eq=False, repr=False)
class Weld(betterproto.Message):
    length: float = betterproto.float_field(1)
    """how long is this weld"""


@dataclass(eq=False, repr=False)
class Bore(betterproto.Message):
    radius: "BilateralTolerance" = betterproto.message_field(1)
    """what is the radius of this bore"""

    depth: float = betterproto.float_field(2)
    """how deep is this bore"""

    has_reamer: bool = betterproto.bool_field(3)
    """if this radius has a reamer that exists for it."""


@dataclass(eq=False, repr=False)
class Postprocess(betterproto.Message):
    post_id: str = betterproto.string_field(1)
    """the unique posprocessing uuid"""

    geom_id: str = betterproto.string_field(2)
    """
    which geometry does this postprocessing operation apply to: if not included
    should be assumed to belong to the parent message. however for operations
    like tolerancing which is: f(repeated PartFabrication)={repeated
    PostProcess} we need to know which geometry it's for.
    """

    method_id: str = betterproto.string_field(3)
    """
    which manufacturing method is this postprocessing operation valid for? i.e.
    "flat", "bent", etc.
    """

    kind: "PostKind" = betterproto.enum_field(4)
    """is this welding, tapping, etc."""

    group: str = betterproto.string_field(5)
    """holes can only be tapped once this looks like 'A1', 'B2', etc"""

    description: str = betterproto.string_field(6)
    """human readable text description"""

    markers: "NdArray" = betterproto.message_field(7)
    """
    the location in part coordinates where the part should indicate the
    operation
    """

    is_default: bool = betterproto.bool_field(8)
    """should this postprocessing operation be selected by default"""

    thread: "Thread" = betterproto.message_field(10, group="details")
    countersink: "Countersink" = betterproto.message_field(11, group="details")
    counterbore: "Counterbore" = betterproto.message_field(12, group="details")
    weld: "Weld" = betterproto.message_field(13, group="details")
    bore: "Bore" = betterproto.message_field(14, group="details")


@dataclass(eq=False, repr=False)
class Mesh(betterproto.Message):
    blob: "FileBlob" = betterproto.message_field(1)
    """A mesh in a neutral format."""


@dataclass(eq=False, repr=False)
class Box(betterproto.Message):
    x: float = betterproto.double_field(1)
    """The length of each side of the Box primitive."""

    y: float = betterproto.double_field(2)
    z: float = betterproto.double_field(3)


@dataclass(eq=False, repr=False)
class Cylinder(betterproto.Message):
    radius: float = betterproto.double_field(1)
    """The radius of the cylinder."""

    height: float = betterproto.double_field(2)
    """The *total* height of the cylinder."""


@dataclass(eq=False, repr=False)
class AnnularCylinder(betterproto.Message):
    """A cylinder with a hole."""

    height: float = betterproto.float_field(3)
    """how tall this the cylinder?"""

    radius_outer: float = betterproto.float_field(4)
    """what is the radius of the outer surface?"""

    radius_inner: float = betterproto.float_field(5)
    """what is the radius of the inner bore?"""


@dataclass(eq=False, repr=False)
class Geometry(betterproto.Message):
    box: "Box" = betterproto.message_field(1, group="geom")
    cylinder: "Cylinder" = betterproto.message_field(2, group="geom")
    annular: "AnnularCylinder" = betterproto.message_field(3, group="geom")
    mesh: "Mesh" = betterproto.message_field(4, group="geom")
    transform: "RigidTransform" = betterproto.message_field(10)
    """
    i.e. for cylinders it moves from its center of mass at the origin (i.e.
    `z`` ranges from `-height/2` to `height/2``) to the desired location in 3D
    space.
    """


@dataclass(eq=False, repr=False)
class Outcome(betterproto.Message):
    """
    Indicate whether something like an analysis or pricing calculation
    succeeded.
    """

    is_completed: bool = betterproto.bool_field(1)
    """Is this outcome completed (is it no longer running?)"""

    is_success: bool = betterproto.bool_field(2)
    """Was this outcome successful?"""

    errors: List["Error"] = betterproto.message_field(3)
    """A list of all errors that occurred."""

    quality: float = betterproto.double_field(4)
    """
    If there is a qualitative "quality" metric for this outcome. For example on
    a PartFabrication message this represents how well the method can make the
    part between 0.0-1.0. A part with pockets can be made with a waterjet but
    only 90% of the volume can be accurately fabricated (i.e. `quality~=0.9`)
    where a milling machine can make 100% of the volume (i.e `quality~=1.0`).
    """

    duration: float = betterproto.double_field(5)
    """
    If this was a billable compute call how long did the computation take?
    """


@dataclass(eq=False, repr=False)
class Timestamp(betterproto.Message):
    seconds: float = betterproto.double_field(1)
    """
    Represents seconds of UTC time since Unix epoch 1970-01-01T00:00:00Z. Must
    be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.
    """


@dataclass(eq=False, repr=False)
class Stock(betterproto.Message):
    stock_id: str = betterproto.string_field(1)
    """a unique identifier for this particular sheet or bar"""

    material_id: str = betterproto.string_field(2)
    """Which material does this apply to: i.e. `abs`, `aluminum_6061_t6`"""

    supplier_id: str = betterproto.string_field(3)
    """Which supplier is providing this material: `metalsdepot`, `mcmaster`"""

    supplier_pn: str = betterproto.string_field(4)
    """
    What is the supplier's part number for this piece of material i.e.
    `95462A515`
    """

    price: "Money" = betterproto.message_field(5)
    """The unit cost of this material."""

    expiry: "Timestamp" = betterproto.message_field(6)
    """When does this quoted price for material expire?"""

    quantity: int = betterproto.uint32_field(8)
    """how many of this stock are required for a job"""

    kind: "StockKind" = betterproto.enum_field(9)
    """What is the simple form factor of this stock."""

    length: float = betterproto.double_field(10)
    """
    If this is a rod `length = width` and is the diameter of the rod. If it is
    a bar or a sheet this is the length and width.
    """

    width: float = betterproto.double_field(11)
    height: float = betterproto.double_field(12)
    """if this is a sheet this is the thickness."""

    units: "UnitSystem" = betterproto.enum_field(15)
    """Are all dimensions in this message meters, inches, etc."""


@dataclass(eq=False, repr=False)
class Interval(betterproto.Message):
    """Define an interval with a minimum and maximum value"""

    min: float = betterproto.double_field(2)
    max: float = betterproto.double_field(3)


@dataclass(eq=False, repr=False)
class Model(betterproto.Message):
    """
    A simple `f(x) = y` defined as a serialized message. This is useful for
    things like feed-rate curves where cutting speed is a function of
    thickness.
    """

    kind: str = betterproto.string_field(1)
    """i.e. `constant`, `polynomial`, `table`, `expression`"""

    model_id: str = betterproto.string_field(2)
    """
    a globally unique identitier i.e. a UUID:
    '83c96039-e77f-4603-a1f0-1a6381de159c'
    """

    units: List[str] = betterproto.string_field(4)
    """
    the units of the X and Y axis i.e. for feed rate: ["inch", "inch/minute"]
    so if you evaluate this model with X in "inch" it produces an "inch/minute"
    result
    """

    keys: List[float] = betterproto.float_field(5)
    """
    i.e for `kind=table`, `keys`` is the X value and `values` is the
    corresponding Y value.
    """

    values: List[float] = betterproto.float_field(6)
    expression: str = betterproto.string_field(7)
    """
    if we have an `expression` kind -_- i.e. "2.9 * volume_support + 1.2 *
    volume"
    """

    is_interpolated: bool = betterproto.bool_field(8)
    """
    is this model allowed to be interpolated this is only used for
    `kind="table"` where if the exact value isn't in the table it will return a
    NaN rather than the interpolated result
    """

    limits: "Interval" = betterproto.message_field(9)
    """
    If this is defined enforce a range limit on the values this `Model` is
    allowed to be evaluated over.
    """


@dataclass(eq=False, repr=False)
class ToolParameters(betterproto.Message):
    """
    Material specific parameters which can be used for path generation.
    Parameters are in units that are supplied from tooling suppliers
    """

    material_id: str = betterproto.string_field(1)
    """The material ID this tool can be used for"""

    surface_feet_per_minute: "Interval" = betterproto.message_field(2)
    """
    "surface feet per minute" The "units of art" for how the rotational speed
    of the end mill should be correlated to the movement speed. Basically if
    you increase the spindle speed you can increase the movement speed to keep
    the amount of material removed per tooth of the end mill the same.
    """

    inch_per_tooth: "Interval" = betterproto.message_field(3)
    """Inch per tooth values."""

    maximum_rpm: float = betterproto.double_field(4)
    """The cap for how fast this tool should be run."""

    radial_depth_of_cut: float = betterproto.double_field(5)
    """
    The percentage of the radius which should be cut per pass. i.e. for a 1"
    diameter end mill `radial_depth_of_cut=0.12` would mean steps of 12% of the
    radius or 0.06" per step.
    """

    is_carbide: bool = betterproto.bool_field(9)
    """Is this tool carbide or HSS?"""

    flutes: int = betterproto.uint32_field(10)
    """how many flutes does this tool have?"""

    use_rough: bool = betterproto.bool_field(11)
    """Should this be used for "roughing," or large volume removal"""

    use_finish: bool = betterproto.bool_field(12)
    """
    Should this tool be used for finish passes, or exactly touching the surface
    of the finish part.
    """


@dataclass(eq=False, repr=False)
class Tool(betterproto.Message):
    """Describes a tool used to cut a path."""

    shape: "ToolShape" = betterproto.enum_field(1)
    """Is this a square end mill, ball-end mill, etc."""

    index: int = betterproto.uint32_field(2)
    """When stored in a tool magazine, what is the index?"""

    parameters: List["ToolParameters"] = betterproto.message_field(5)
    """
    The materials this tool is valid for and values that can be used to
    calculate the "speeds and feeds" for each material.
    """

    radius: float = betterproto.double_field(6)
    """The cutting radius in meters."""

    length_cut: float = betterproto.double_field(7)
    """What length of the tool can cut sideways."""

    length_total: float = betterproto.double_field(8)
    """What is the total length of the tool from spindle to tip."""

    suppliers: List["CotsMatch"] = betterproto.message_field(9)
    """
    Information about where to get this tool including supplier and price.
    """

    speed_feed: float = betterproto.double_field(11)
    """
    If passed override linear feed rate from `ToolParameters` units are in
    mm/min and will be passed to the `F` g-code.
    """

    speed_rpm: float = betterproto.double_field(13)
    """
    If passed override spindle speed from `ToolParameters` Will be passed to
    the `S` g-code
    """


@dataclass(eq=False, repr=False)
class BoundingBox3D(betterproto.Message):
    """
    An axis-aligned bounding box in 3d. i.e., the box defined as  lower.x <= x
    <= upper.x &&  lower.y <= y <= upper.y &&  lower.z <= z <= upper.z
    """

    lower: "Point3D" = betterproto.message_field(1)
    upper: "Point3D" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class Point3D(betterproto.Message):
    """A 3D point in space."""

    x: float = betterproto.double_field(1)
    y: float = betterproto.double_field(2)
    z: float = betterproto.double_field(3)


@dataclass(eq=False, repr=False)
class Segment(betterproto.Message):
    """
    A generic segment which can be any of a helix, circular arc, or line
    segment depending on parameter values
    """

    start: "Point3D" = betterproto.message_field(1)
    """The starting point of the segment."""

    final: "Point3D" = betterproto.message_field(2)
    """The ending point of the segment."""

    angle: float = betterproto.double_field(3)
    """
    What is the angle of the arc section in radians? Straight lines have an
    angle of 0.0 This will always take the shortest arc so `angle < pi`
    Counterclockwise arcs are positive and clockwise are negative
    """

    tag: "SegmentTag" = betterproto.enum_field(4)
    """The segment's role e.g., removing material vs. repositioning"""

    tool_index: int = betterproto.uint32_field(5)
    """The index of the tool this segment is cut with."""

    radius_override: float = betterproto.double_field(10)
    """An override radius used for internal logic."""


@dataclass(eq=False, repr=False)
class ToolPlane(betterproto.Message):
    transform: "RigidTransform" = betterproto.message_field(1)
    """Rigid transform relative to world/material frame"""

    limits: "BoundingBox3D" = betterproto.message_field(2)
    """The limits of tool-tip motion in the above transform"""

    levels: List[float] = betterproto.double_field(3)
    """The unique depth levels consumed by this tool plane."""


@dataclass(eq=False, repr=False)
class SegmentPath(betterproto.Message):
    segments: List["Segment"] = betterproto.message_field(1)
    """Connected segments the end of a tool moves along."""

    tools: List["Tool"] = betterproto.message_field(2)
    """The library of tools each segment references in `tool_index`"""

    plane: "ToolPlane" = betterproto.message_field(3)
    """What are the details about the toolplane for these cuts."""

    stats: "SegmentStatistics" = betterproto.message_field(4)
    """How long did this path take to execute?"""


@dataclass(eq=False, repr=False)
class SegmentStatistics(betterproto.Message):
    """Hold information about path duration and length."""

    length: float = betterproto.double_field(1)
    """The total path length in meters."""

    duration: float = betterproto.double_field(2)
    """
    The duration of the path when executed at 100% of the velocity requested by
    the tool.
    """

    tool_changes: int = betterproto.uint32_field(3)
    """How many tool changes occurred in this path?"""


@dataclass(eq=False, repr=False)
class MillPlan(betterproto.Message):
    """
    A message containing all the information required to translate the job into
    a full output format which initially includes a PDF plan and a `camotics`
    simulation but could include other simulation formats (i.e. MasterCAM)
    """

    part: "Geometry" = betterproto.message_field(1)
    """The triangulated mesh of the desired part."""

    stock: "Geometry" = betterproto.message_field(2)
    """What stock are we starting with."""

    paths: List["SegmentPath"] = betterproto.message_field(3)
    """Multiple toolpaths and fixtures."""


@dataclass(eq=False, repr=False)
class MillSettings(betterproto.Message):
    material_id: str = betterproto.string_field(1)
    """What material is this being cut from?"""

    machine: "MillMachine" = betterproto.message_field(2)
    """The machine analysis should be run with."""

    tools: List["Tool"] = betterproto.message_field(3)
    """The specific tools available."""

    detail: "GpuDetail" = betterproto.enum_field(4)
    """
    What resolution should *roughing* operations be calculated in. Note that
    "finish" passes are done directly from the tesselated geometry and are not
    calculated using voxel methods.
    """

    return_volume: bool = betterproto.bool_field(5)
    """Return the KDC file containing voxel data at each radius."""

    return_gcode: bool = betterproto.bool_field(6)
    """Calculate and return G-code toolpaths that are machine-ready."""

    return_plan: bool = betterproto.bool_field(7)
    """
    Return a `MillPlan` object which is designed to be used programatically.
    """

    skip_fixture_collisions: bool = betterproto.bool_field(8)
    """Check for fixture collisions."""

    default_radial_depth_of_cut: float = betterproto.float_field(9)
    """
    If we haven't been passed an array of tools use this value for the default
    radial depth of cut.
    """

    plane_normals: "NdArray" = betterproto.message_field(10)
    """
    If passed tell the preprocessor to ignore internal heuristics and use these
    (n, 3) float array of unit vectors to assign cut planes.
    """

    skip_prune: bool = betterproto.bool_field(11)
    """
    The total number of operations is `len(tools) * len(preprocess.directions)`
    as every tool is tried from every direction. This generally produces far
    too many operations to be useful unless there is only one tool and one
    direction but may be useful for debugging or specific applications. Pruning
    uses the GPU to determine which tools actually cut anything *before* any
    toolpathing and will return results that are a subset of `tools *
    preprocess.directions`.
    """

    preprocess: "MillPreprocess" = betterproto.message_field(12)
    """
    The preprocessed mesh: note most applications should use our default
    preprocessor and *not* pass this as our preprocessor does things like plug
    drill holes and pick stock, but if you have existing internal logic you can
    skip our heuristics by passing this explicitly.
    """


@dataclass(eq=False, repr=False)
class MillMachine(betterproto.Message):
    """
    The parameters for a milling machine used in CarveWizard. All dimensions
    are in meters.
    """

    tool_pad: float = betterproto.double_field(1)
    """
    How much to pad the tool for tool-fixture collision checks. Pads the radius
    of the tool and the bottom of the tool.
    """

    spindle_length: float = betterproto.double_field(2)
    """how long is the spindle cylinder for collision checks"""

    spindle_radius: float = betterproto.double_field(3)
    """What is the radius of the spindle cylinder."""

    spindle_pad: float = betterproto.double_field(4)
    """How much should the spindle be padded to avoid collisons."""

    max_z_travel: float = betterproto.double_field(5)
    """What is the maximum distance that the spindle can travel in Z?"""

    extents: List[float] = betterproto.double_field(6)
    """What is the size of the work volume of the milling machine."""

    feed_max: float = betterproto.double_field(7)
    """The maximum feed rate in meters per second."""

    rpm_max: float = betterproto.double_field(8)
    """The maximum spindle speed in rotations per minute."""


@dataclass(eq=False, repr=False)
class MillPreprocess(betterproto.Message):
    """
    Before running carving analysis we have to approximate certain information.
    """

    directions: "NdArray" = betterproto.message_field(2)
    """
    an ordered (n, 3) double array of unit vectors of possible directions.
    """

    stock: "Stock" = betterproto.message_field(3)
    """What is the stock material this is being constructed out of?"""

    stock_geometry: "Geometry" = betterproto.message_field(4)
    """A model of the stock in the frame of the preprocessed mesh."""

    mesh: "Geometry" = betterproto.message_field(5)
    """The preprocessor may have edited the geometry."""

    drills: List["CutDrill"] = betterproto.message_field(6)
    """
    The preprocessor may have extracted drill cuts as these are a special case
    that generally does not
    """

    collision: List["Geometry"] = betterproto.message_field(7)
    """Collision geometry to avoid. Must be the same length as `directions`"""


@dataclass(eq=False, repr=False)
class Fixture(betterproto.Message):
    strategy: "FixtureStrategy" = betterproto.enum_field(1)
    """What strategy is this fixture using?"""

    collision: "Geometry" = betterproto.message_field(2)
    """Collision geometry for this fixture."""

    normal: List[float] = betterproto.double_field(3)
    """What is the normal vector of this fixture operation."""


@dataclass(eq=False, repr=False)
class CutMill(betterproto.Message):
    volume: float = betterproto.double_field(1)
    """Volume remove for each radius of the mill cut."""

    radius: float = betterproto.double_field(2)
    """Radius of the tool in meters."""

    tool: "Tool" = betterproto.message_field(3)
    """What tool was this operation using."""


@dataclass(eq=False, repr=False)
class CutDrill(betterproto.Message):
    radius: float = betterproto.double_field(1)
    """Which drill bit radius is used?"""

    depth: List[float] = betterproto.double_field(2)
    """How deep is each hole?"""

    origins: "NdArray" = betterproto.message_field(3)
    """Where is the origin for each hole"""

    normal: List[float] = betterproto.double_field(4)
    """What is the normal vector for each hole?"""

    thru: bool = betterproto.bool_field(5)
    """Are these drilled holes through the entire part?"""

    labels: List[str] = betterproto.string_field(6)
    """What are the labels for the drill, i.e. "17/64 Drill"""


@dataclass(eq=False, repr=False)
class CutFace(betterproto.Message):
    radius: float = betterproto.double_field(1)
    """The radius of the face-mill cutter."""

    area: float = betterproto.double_field(2)
    """The area to be faced."""

    depth: float = betterproto.double_field(3)
    """The depth to be faced."""


@dataclass(eq=False, repr=False)
class MillFabrication(betterproto.Message):
    """This is an analysis result suitable for quoting."""

    stock: "Stock" = betterproto.message_field(1)
    """What is the raw material this part was milled from?"""

    fixtures: List["Fixture"] = betterproto.message_field(2)
    """How is this part being held to cut?"""

    cuts: List["MillFabricationCut"] = betterproto.message_field(3)
    """Ordered list of operations required to generate this part."""

    volume: "FileBlob" = betterproto.message_field(4)
    """the volumetric carving information in KDC format"""

    gcode: List["FileBlob"] = betterproto.message_field(5)
    """
    The "G-code" for the milled part in addition to supporting files. There is
    one G-code file per tool plane and a corresponding Camotics simulation
    definition for each toolplane.
    """

    plan: "MillPlan" = betterproto.message_field(6)
    """
    The same data as in the G-code but in an internal machine-usable format.
    """

    pre: "MillPreprocess" = betterproto.message_field(7)
    """The preprocessor information that was used."""

    machine: "MillMachine" = betterproto.message_field(8)
    """The machine that this fabrication was calculated for."""


@dataclass(eq=False, repr=False)
class MillFabricationCut(betterproto.Message):
    mill: "CutMill" = betterproto.message_field(1, group="op")
    drill: "CutDrill" = betterproto.message_field(2, group="op")
    face: "CutFace" = betterproto.message_field(3, group="op")
    fixture_index: int = betterproto.uint32_field(5)
    """Which fixturing setup is this operation using."""

    label: str = betterproto.string_field(6)
    """What is a human-readable label for this operation?"""


@dataclass(eq=False, repr=False)
class FlatFabrication(betterproto.Message):
    perimeter: float = betterproto.double_field(1)
    """How long is the internal *and* external boundary."""

    holes: List[float] = betterproto.double_field(2)
    """
    The size of the largest dimension of the axis-aligned bounding box for each
    interior curve of the flat pattern.
    """

    extents: List[float] = betterproto.double_field(3)
    """The (2,) oriented bounding box size of the flat pattern."""

    area: float = betterproto.double_field(4)
    """The area of the flat pattern."""

    rapids: float = betterproto.double_field(5)
    """
    How much distance is there in a path that visits every interior of the flat
    pattern.
    """

    thickness: float = betterproto.double_field(6)
    """How thick was the original geometry."""

    flattened: "FileBlob" = betterproto.message_field(7)
    """
    The flattened geometry most likely as our internal SVG format which
    preserves metadata.
    """

    to_flattened: "RigidTransform" = betterproto.message_field(8)
    """
    A (4, 4) homogeneous rigid transform. In 3D the geometry of the source
    geometry of a plate-with-holes is in an entirely arbitrary position and
    rotation. When we generate the flat pattern and save it as
    `FlatFabrication.flattened`, it is originally a projection onto a plane in
    that arbitrary frame this transform moves the arbitrary frame onto the XY
    plane. The scene graph may contain multiple instances of that geometry, and
    we use this transform in the tolerance calculation to move every 2D hole on
    the plane into the full 3D scene graph.
    """


@dataclass(eq=False, repr=False)
class CotsFabrication(betterproto.Message):
    """A commercial-off-the-shelf part like a ball bearing."""

    matches: List["CotsMatch"] = betterproto.message_field(1)
    """
    the part can match to many different commerical parts and the same part
    from a different supplier is a different match.
    """

    cylinder: "Cylinder" = betterproto.message_field(4, group="primitive")
    annular: "AnnularCylinder" = betterproto.message_field(5, group="primitive")


@dataclass(eq=False, repr=False)
class BentFabrication(betterproto.Message):
    """A part fabricated on a press-brake."""

    bend_count: int = betterproto.uint32_field(1)
    """How many individual bend operations are there?"""

    bend_setups: int = betterproto.uint32_field(2)
    """
    How many bend setups are there? These numbers are different because
    sometimes bends can be combined into a single setup operation if they are
    colinear and have the same radius.
    """

    bend_k: List[float] = betterproto.float_field(3)
    """what K-factor was the part flattened with."""

    bend_angle: List[float] = betterproto.float_field(4)
    """What is the angle of each bend?"""

    bend_radii: List[float] = betterproto.float_field(5)
    """What is the radius of each bend?"""

    flat: "FlatFabrication" = betterproto.message_field(6)
    """The details of the flat pattern."""

    regions: "BentFabricationBentRegions" = betterproto.message_field(7)
    """what is the transform for each region back into 3D space"""


@dataclass(eq=False, repr=False)
class BentFabricationBentRegions(betterproto.Message):
    wkt: str = betterproto.string_field(1)
    """a MultiPolygon outline in the "well known text" format"""

    to_3_d: "NdArray" = betterproto.message_field(2)
    """
    a matrix to move each polygon back into 3D (len(wkt.geoms), 4, 4) float
    """


@dataclass(eq=False, repr=False)
class ManualFabrication(betterproto.Message):
    """A manual fabrication is a placeholder."""

    pass


@dataclass(eq=False, repr=False)
class RollFabrication(betterproto.Message):
    """
    A part cut from a flat sheet and then rolled into a cylinder with cutouts.
    """

    height: float = betterproto.double_field(1)
    """The maximum height of the rolled cylinder in inches."""

    diameter: float = betterproto.double_field(2)
    """The exterior diameter of the resulting rolled part."""

    flat: "FlatFabrication" = betterproto.message_field(3)
    """The details of the flat pattern."""


@dataclass(eq=False, repr=False)
class TurnFabrication(betterproto.Message):
    """A part made entirely on a lathe with no milled features."""

    height: float = betterproto.double_field(1)
    """the maximum height of the part in inches"""

    diameter: float = betterproto.double_field(2)
    """the bounding cylinder diameter."""

    volume: float = betterproto.double_field(3)
    """The final part volume."""

    inner_diameter: float = betterproto.double_field(4)
    """if there is a thru-bore what is the minimum diameter."""

    profile: "FileBlob" = betterproto.message_field(5)
    """the 2D profile geometry"""


@dataclass(eq=False, repr=False)
class AddFabrication(betterproto.Message):
    """
    A part made through additive fabrication methods also known as
    "3D-printing."
    """

    planes: List["AddFabricationPlane"] = betterproto.message_field(5)
    """the different printing plane options."""


@dataclass(eq=False, repr=False)
class AddFabricationPlane(betterproto.Message):
    """
    A printed part can be aligned with different print planes which will effect
    the final part geometry as well as the amount of support material used.
    """

    origin: List[float] = betterproto.float_field(1)
    """The (3,) position of the plane origin."""

    normal: List[float] = betterproto.float_field(2)
    """The (3,) unit vector for the plane normal."""

    area: float = betterproto.double_field(3)
    """The projected area of the part onto this plane."""

    height: float = betterproto.double_field(4)
    """The height this part rises above the plane."""

    extents: List[float] = betterproto.float_field(5)
    """The (2,) oriented bounding box size on this plane."""

    volume: float = betterproto.double_field(6)
    """
    the total volume of the resulting part when printed against this plane.
    """

    volume_support: float = betterproto.double_field(7)
    """
    The amount of overhung "support" volume when this part is printed against
    this plane.
    """


@dataclass(eq=False, repr=False)
class PartFabrication(betterproto.Message):
    """The overall methods a part may be manufactured with."""

    geom_id: str = betterproto.string_field(1)
    """Which geometry identifier does this part refer to."""

    geom_name: str = betterproto.string_field(2)
    """if this geometry has a human-readable name store it here"""

    method_id: str = betterproto.string_field(3)
    """Which of the `PartFabrication.details` is populated?"""

    outcome: "Outcome" = betterproto.message_field(4)
    """How well did the fabrication by this method work."""

    defaults: "PartConfiguration" = betterproto.message_field(5)
    """what are the default values for this part"""

    posts: List["Postprocess"] = betterproto.message_field(6)
    """The `method_id`-specific postprocessing options."""

    drawing: "FileBlob" = betterproto.message_field(7)
    """The `method_id`-specific 2D drawing to show to the user."""

    extents: List[float] = betterproto.double_field(8)
    """The 3D size of the final part in *meters*"""

    flat: "FlatFabrication" = betterproto.message_field(10, group="details")
    bent: "BentFabrication" = betterproto.message_field(11, group="details")
    roll: "RollFabrication" = betterproto.message_field(12, group="details")
    mill: "MillFabrication" = betterproto.message_field(13, group="details")
    cots: "CotsFabrication" = betterproto.message_field(14, group="details")
    add: "AddFabrication" = betterproto.message_field(15, group="details")
    turn: "TurnFabrication" = betterproto.message_field(16, group="details")
    manual: "ManualFabrication" = betterproto.message_field(17, group="details")


@dataclass(eq=False, repr=False)
class MaterialConfig(betterproto.Message):
    """
    A message for a machine indicating how it performs on specific materials,
    i.e. to calculate the feed rate on 0.25" thick aluminum.
    """

    material_id: str = betterproto.string_field(1)
    """
    which material does this config correspond to, i.e. `aluminum_6061_t6`
    """

    model_id: str = betterproto.string_field(2)
    """
    which model does this material use? i.e.
    `01f563b5-cb25-4e74-9765-49adb891d26f``
    """

    model_use: str = betterproto.string_field(3)
    """
    what is this model used for in this instance i.e. `pierce`, `feed`,
    `rapids`
    """


@dataclass(eq=False, repr=False)
class Machine(betterproto.Message):
    """A machine which can be used to cut various parts."""

    machine_id: str = betterproto.string_field(1)
    """What is the unique identifier for this machine i.e. `laser2k`"""

    label: str = betterproto.string_field(2)
    """
    What is the user-facing name of the machine i.e. "2kW Amada Fiber Laser"
    """

    method_id: str = betterproto.string_field(3)
    """Which process is this machine for. i.e. `flat`, `bent`, etc"""

    shop_id: str = betterproto.string_field(4)
    """Which shop does this machine belong to. i.e. `atomatic`"""

    address_id: str = betterproto.string_field(6)
    """Where is this machine physically located?"""

    work_rate: "Money" = betterproto.message_field(7)
    """
    How much does this machine bill the customer in units of `Money / second`
    """

    setups: str = betterproto.string_field(8)
    """
    How long does this machine take to set up in seconds? this is a `model_id`
    contained in `Machine.models`
    """

    rapids: str = betterproto.string_field(9)
    """
    What is the maximum speed this machine can move a distance? this is a
    `model_id` contained in `Machine.models`
    """

    extents: List[float] = betterproto.double_field(10)
    """What is the largest part this machine can handle?"""

    materials: List["MaterialConfig"] = betterproto.message_field(11)
    """
    Which materials correspond to which cutting models keyed {'material_id':
    {'model_name': 'model_id'}} i.e. `{'aluminum_6061_t6`: {'pierce':
    '000-00'}}`
    """

    models: List["Model"] = betterproto.message_field(12)
    """
    includes the per-material cost information, such as feed rate curves,
    pierce time curves, setup times, etc. these are stored separately from
    materials as many of them are duplicates (i.e. different aluminum alloys)
    keyed {'model_id': Model}
    """


@dataclass(eq=False, repr=False)
class Operation(betterproto.Message):
    """An operation which"""

    operation_id: str = betterproto.string_field(1)
    """if we were tracking these in an ERP system"""

    price: "Money" = betterproto.message_field(2)
    """how much does this component of the price cost?"""

    is_combinable: bool = betterproto.bool_field(3)
    """
    Is this a "combinable setup" if this part of the price needs to be filled
    in later for example setups will be combined at the bottom of the invoice
    rather than listed as a subcomponent here if true: price represents ceil(
    sum(utilization) ) * price
    """

    duration: float = betterproto.double_field(4)
    """
    how long did this operation take in seconds if `combine=True` this is the
    length of 1.0 utilization
    """

    utilization: float = betterproto.double_field(5)
    """
    how much of this setup does ONE part consume ONLY used if `combine=True`
    """

    note: str = betterproto.string_field(6)
    """
    a user-facing note about this price i.e. "Amada 4kW Fiber Laser, 10 "
    """


@dataclass(eq=False, repr=False)
class LinePrice(betterproto.Message):
    line_id: str = betterproto.string_field(1)
    """the unique identifier for the part this price is for"""

    geom_id: str = betterproto.string_field(2)
    """the geometry this price was generated for"""

    method_id: str = betterproto.string_field(3)
    """the fabrication method this is valid for, i.e. `flat`"""

    shop_id: str = betterproto.string_field(4)
    """what vendor is producing this part"""

    address_id: str = betterproto.string_field(5)
    """where exactly is this part being produced"""

    price: "Money" = betterproto.message_field(6)
    """the *unit* price of the part"""

    quantity: int = betterproto.uint32_field(7)
    """this price is *only valid at a specific quantity.*"""

    mass: float = betterproto.double_field(8)
    """how much does the *each* part weigh in *kilograms*"""

    extents: List[float] = betterproto.double_field(9)
    """how large is *each* part in *meters*"""

    stock: "Stock" = betterproto.message_field(10)
    """the raw material input `stock` the part was made from."""

    operations: List["Operation"] = betterproto.message_field(11)
    """
    if a part consists of "buy metal sheet, cut on laser, ..." return a list of
    these operations which can be displayed to the user as an "itemized" price
    or can be used when released to manufacturing as a "todo list". ERP systems
    sometimes have the list of operations with a signature and barcode next to
    each op and we could do a thing with a QR code if desired.
    """

    outcome: "Outcome" = betterproto.message_field(12)
    """If this price had an error list here."""


@dataclass(eq=False, repr=False)
class LineSpec(betterproto.Message):
    """a fully configured part ready to be released to manufacturing"""

    line_id: str = betterproto.string_field(1)
    """globally unique identifier for this part"""

    geom_id: str = betterproto.string_field(2)
    """
    locally unique identifier which indicates which geometry in the local
    scenes this is
    """

    shop_id: str = betterproto.string_field(3)
    """which shop is assigned to make this part"""

    name: str = betterproto.string_field(4)
    """nicer display name"""

    fab: "PartFabrication" = betterproto.message_field(10)
    """fabrication data from analysis pipeline"""

    config: "PartConfiguration" = betterproto.message_field(11)
    """full configuration that can be priced"""


@dataclass(eq=False, repr=False)
class OrderPrice(betterproto.Message):
    total: "Money" = betterproto.message_field(1)
    """the sum price the customer was billed"""

    lines: "Money" = betterproto.message_field(2)
    """the sum price of all parts in this order"""

    setups: "Money" = betterproto.message_field(3)
    """the sum of all setups after combining"""

    shipping: "Money" = betterproto.message_field(4)
    """total shipping cost billed to customer"""

    taxes: "Money" = betterproto.message_field(5)
    """taxes billed to customer"""

    discount: "Money" = betterproto.message_field(6)
    """discount, usually negative: note that it is signed"""


@dataclass(eq=False, repr=False)
class PriceMetadata(betterproto.Message):
    """Contains mappings of IDs to metadata used for pricing."""

    stock: List["Stock"] = betterproto.message_field(1)
    """
    The available stock materials that can be used by the configured parts.
    """

    machines: List["Machine"] = betterproto.message_field(2)
    """The available machines that can be used to cut the parts."""

    addresses: List["PostalAddress"] = betterproto.message_field(3)
    """what are the facilities that are mailing stuff."""


@dataclass(eq=False, repr=False)
class ShippingRate(betterproto.Message):
    """a rate is a fully-quoted purchasable shipping option."""

    price: "Money" = betterproto.message_field(3)
    """how much does this method cost in total"""

    parcels: List["ShippingParcel"] = betterproto.message_field(4)
    """may contain different shippers"""


@dataclass(eq=False, repr=False)
class ShippingParcel(betterproto.Message):
    ship_from: "PostalAddress" = betterproto.message_field(1)
    ship_to: "PostalAddress" = betterproto.message_field(2)
    line_id: List[str] = betterproto.string_field(3)
    """which of the LinePrice parts are contained in this parcel."""

    extents: List[float] = betterproto.double_field(4)
    """the 3D bounding box for one parcel in meters"""

    weight: float = betterproto.double_field(5)
    """the weight of the parcel in kilograms"""

    provider: str = betterproto.string_field(6)
    """i.e. "shippo", "shipengine", "easypost"""

    provider_id: str = betterproto.string_field(7)
    """the unique identifier used to purchase the label"""

    label: "FileBlob" = betterproto.message_field(8)
    """i.e. a PNG shipping label (Only populated after purchase.)"""

    tracking_url: str = betterproto.string_field(9)
    """a tracking url (Only populated after purchase.)"""


@dataclass(eq=False, repr=False)
class GeometrySummary(betterproto.Message):
    """A summary of a single geometry found in the scene."""

    geom_id: str = betterproto.string_field(1)
    """the re-usable id assigned to the geometry"""

    node_id: List[str] = betterproto.string_field(2)
    """a reference to the geometry instance being referenced"""

    name: str = betterproto.string_field(3)
    """the human-readable name of the geometry"""

    preview: "FileBlob" = betterproto.message_field(4)
    """If requested a raster image preview."""


@dataclass(eq=False, repr=False)
class Scene(betterproto.Message):
    """One or more 2D or 3D parts represented as a single geometry file."""

    neutral: "FileBlob" = betterproto.message_field(1)
    """
    one or more files in a neutral format, currently: `glb` for 3D `svg` for 2D
    """

    name: str = betterproto.string_field(2)
    """The name of the scene, usually set to the input filename."""

    geometries: List["GeometrySummary"] = betterproto.message_field(3)
    """which geometry is contained in this scene"""

    preview: "FileBlob" = betterproto.message_field(4)
    """If raster images were requested."""


@dataclass(eq=False, repr=False)
class Order(betterproto.Message):
    """a placed order"""

    order_id: str = betterproto.string_field(1)
    """the uuid with hyphens"""

    shop_id: str = betterproto.string_field(2)
    """the id of the shop the *order was placed from*"""

    shipping: "PostalAddress" = betterproto.message_field(3)
    """where is order shipped to"""

    billing: "PostalAddress" = betterproto.message_field(4)
    """where is order billed to"""

    lines: List["LineSpec"] = betterproto.message_field(5)
    """fully configured parts in the order"""

    prices: List["LinePrice"] = betterproto.message_field(6)
    """the corresponding prices for the parts"""

    models: List["Scene"] = betterproto.message_field(9)
    """the models for the parts"""

    originals: List["FileBlob"] = betterproto.message_field(10)
    """the original CAD files for the order"""

    parcels: List["ShippingParcel"] = betterproto.message_field(11)
    """the parcels this order is shipping with"""


@dataclass(eq=False, repr=False)
class Job(betterproto.Message):
    """a Job is a released-to-manufacture package"""

    shop_id: str = betterproto.string_field(1)
    """which shop is making this"""

    order_id: str = betterproto.string_field(2)
    """which order was this job created from"""

    job_id: str = betterproto.string_field(3)
    """unique identifier for this job"""

    part_id: List[str] = betterproto.string_field(4)
    """the parts being manufactured by this job"""

    amount: "Money" = betterproto.message_field(5)
    """
    the total amount of money that will be disbursed to the shop on completion
    shipping which will be either paid by us or invoiced separately.
    """

    summary: "FileBlob" = betterproto.message_field(6)
    """A PDF document with quantities, drawings shipping labels, etc."""

    files: List["FileBlob"] = betterproto.message_field(7)
    """
    any additional reference files, including flattened DXF drawings, original
    models, etc.
    """

    parcels: List["ShippingParcel"] = betterproto.message_field(8)
    """the parcels this order is shipping with"""


@dataclass(eq=False, repr=False)
class FabricationSettings(betterproto.Message):
    """A configuration for the manufacturing analysis."""

    method_id: List[str] = betterproto.string_field(1)
    """
    Specify which methods you want the pipeline to analyze. If unspecified will
    run and return all methods. Valid options include: `mill`, `flat`, `bent`,
    `roll`, `add`, `cots`.
    """

    mill: "MillSettings" = betterproto.message_field(2)
    """Detailed settings for the milling geometry"""

    bent: "BendSettings" = betterproto.message_field(3)
    """Settings for flattening objects, including K-factors, etc"""

    flat: "FlatSettings" = betterproto.message_field(4)
    """Settings for flat pattern outputs."""


@dataclass(eq=False, repr=False)
class KFactor(betterproto.Message):
    """
    Bent parts have flat patterns produced using these material and radius-
    ratio specific settings.
    """

    material_id: str = betterproto.string_field(1)
    """
    a material id match pattern string like `aluminum_6061_t6` or including
    wildcards like `aluminum_*`.
    """

    radius_fraction: List[float] = betterproto.double_field(2)
    """What is the ratio of bend radius to sheet thickness."""

    k_factor: List[float] = betterproto.double_field(3)
    """
    what is the k-factor at that ratio? 0.5 means flatten at the centerline of
    the sheet. 0.0 means flatten at the inner surface of the bend.
    """


@dataclass(eq=False, repr=False)
class BendSettings(betterproto.Message):
    k_factor: List["KFactor"] = betterproto.message_field(4)
    """For bent sheet metal parts."""


@dataclass(eq=False, repr=False)
class FlatSettings(betterproto.Message):
    undersize_holes: float = betterproto.double_field(1)
    """
    undersize any "holes" or "interior region that is circular" example:
    `hole_diameter=1.0`, `undersize_holes=0.125` the output geometry would have
    a hole diameter of `0.875`
    """


@dataclass(eq=False, repr=False)
class DisbursementPolicy(betterproto.Message):
    """A model for disbursing funds."""

    fee_percent: float = betterproto.double_field(1)
    """A percentage fee per-transactions where 1.0% = 0.01"""

    fee_fixed: "Money" = betterproto.message_field(2)
    """A fixed fee per-transaction in USD."""

    fee_monthly: "Money" = betterproto.message_field(3)
    """A fixed fee if the shop is billed monthly."""

    cc_percent: float = betterproto.double_field(4)
    """
    Credit card charge rate from supplier. For stripe this is 2.9% + $0.30 per
    transaction.
    """

    cc_fixed: "Money" = betterproto.message_field(5)
    """What is the fixed charge per credit card transaction."""
