# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: kerfed/protos/api/v1/cam.proto, kerfed/protos/api/v1/geometry.proto, kerfed/protos/api/v1/order.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    TYPE_CHECKING,
    Dict,
    List,
    Optional,
)

import betterproto
import grpclib
from betterproto.grpc.grpclib_server import ServiceBase

from ...common import v1 as __common_v1__


if TYPE_CHECKING:
    import grpclib.server
    from betterproto.grpc.grpclib_client import MetadataLike
    from grpclib.metadata import Deadline


@dataclass(eq=False, repr=False)
class PackRequest(betterproto.Message):
    """
    Request flat fabrications to be packed or "nested" onto sheets and produce
    a machine-ready list of DXF or SVG files.
    """

    parts: List["__common_v1__.FlatFabrication"] = betterproto.message_field(1)
    """The flat parts being packed, with `flattened` populated"""

    quantity: List[int] = betterproto.uint32_field(2)
    """A length-matching"""

    available: List["__common_v1__.Stock"] = betterproto.message_field(3)
    """
    Sheet stock with thickness and extents specified. If not passed all parts
    will be put onto the same sheet.
    """

    undersize_drill: bool = betterproto.bool_field(4)
    """Should holes be undersized."""

    format: str = betterproto.string_field(5)
    """
    Output file format. Acceptable values are 'svg' and 'dxf' and the default
    output format is 'dxf'.
    """


@dataclass(eq=False, repr=False)
class PackResponse(betterproto.Message):
    packed: List["__common_v1__.FileBlob"] = betterproto.message_field(1)
    """Packed result as a DXF or SVG."""

    sheets: List["__common_v1__.Stock"] = betterproto.message_field(2)
    """The sheet size for each packed value."""


@dataclass(eq=False, repr=False)
class GeometryRequest(betterproto.Message):
    """Request a CAD file to be fully analyzed by the geometry pipeline."""

    source: "__common_v1__.FileBlob" = betterproto.message_field(1)
    """Raw CAD geometry to be analyzed in a supported format."""

    source_units: str = betterproto.string_field(2)
    """
    If the raw file is in a format that does not include unit information (i.e.
    SVG, DXF, STL, OBJ) specify the file's units through this request. If not
    passed the pipeline will "guess" the unit system from irregular metadata
    which may be incorrect.
    """

    brand: "__common_v1__.Brand" = betterproto.message_field(3)
    """
    Apply brand preferences to generated user-facing material i.e. apply a
    specific logo, display units (mm vs inch), address, etc.
    """

    settings: "__common_v1__.FabricationSettings" = betterproto.message_field(4)
    """
    Edit detailed settings for each manufacturing process such as the maximum
    spindle speed of milling machines, k-factors for flattening sheet metal,
    etc.
    """

    return_previews: bool = betterproto.bool_field(5)
    """Should the pipeline render rasterized previews of each part?"""

    return_interference: bool = betterproto.bool_field(6)
    """
    Should the pipeline calculate part-part interferences and then add
    additional postprocessing operations where required?
    """

    return_proprietary: bool = betterproto.bool_field(7)
    """
    Enable potentially expensive proprietary formats like SLDPRT, SLDASM, IPT,
    X_B, etc. Note that these are licensed from third parties and are disabled
    for most API accounts unless you have had us enable them.
    """


@dataclass(eq=False, repr=False)
class GeometryResponse(betterproto.Message):
    outcome: "__common_v1__.Outcome" = betterproto.message_field(1)
    """
    Is this geometry analysis complete yet? Clients should check
    `outome.is_completed` before accessing other properties.
    """

    analysis: List["__common_v1__.PartFabrication"] = betterproto.message_field(2)
    """The fabrication analysis."""

    scene: "__common_v1__.Scene" = betterproto.message_field(3)
    """the loaded file in a neutral format"""


@dataclass(eq=False, repr=False)
class PriceRequest(betterproto.Message):
    """Generate prices for one or more fully specified parts."""

    spec: List["__common_v1__.LineSpec"] = betterproto.message_field(1)
    """The fabrication analysis and customer configuration of a part."""

    metadata: "__common_v1__.PriceMetadata" = betterproto.message_field(2)
    """The pricing data for the shop requesting a price."""

    shipping: "__common_v1__.PostalAddress" = betterproto.message_field(3)
    """
    The shipping address of the requested parts to allow the vendor selection
    algorithm to weight transit distance.
    """


@dataclass(eq=False, repr=False)
class PriceResponse(betterproto.Message):
    price: List["__common_v1__.LinePrice"] = betterproto.message_field(1)
    """Prices for the requested parts."""


class CamServiceStub(betterproto.ServiceStub):
    async def pack(
        self,
        pack_request: "PackRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PackResponse":
        return await self._unary_unary(
            "/kerfed.protos.api.v1.CAMService/Pack",
            pack_request,
            PackResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class GeometryServiceStub(betterproto.ServiceStub):
    async def geometry(
        self,
        geometry_request: "GeometryRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "GeometryResponse":
        return await self._unary_unary(
            "/kerfed.protos.api.v1.GeometryService/Geometry",
            geometry_request,
            GeometryResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class OrderServiceStub(betterproto.ServiceStub):
    async def price(
        self,
        price_request: "PriceRequest",
        *,
        timeout: Optional[float] = None,
        deadline: Optional["Deadline"] = None,
        metadata: Optional["MetadataLike"] = None
    ) -> "PriceResponse":
        return await self._unary_unary(
            "/kerfed.protos.api.v1.OrderService/Price",
            price_request,
            PriceResponse,
            timeout=timeout,
            deadline=deadline,
            metadata=metadata,
        )


class CamServiceBase(ServiceBase):

    async def pack(self, pack_request: "PackRequest") -> "PackResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_pack(
        self, stream: "grpclib.server.Stream[PackRequest, PackResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.pack(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/kerfed.protos.api.v1.CAMService/Pack": grpclib.const.Handler(
                self.__rpc_pack,
                grpclib.const.Cardinality.UNARY_UNARY,
                PackRequest,
                PackResponse,
            ),
        }


class GeometryServiceBase(ServiceBase):

    async def geometry(self, geometry_request: "GeometryRequest") -> "GeometryResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_geometry(
        self, stream: "grpclib.server.Stream[GeometryRequest, GeometryResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.geometry(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/kerfed.protos.api.v1.GeometryService/Geometry": grpclib.const.Handler(
                self.__rpc_geometry,
                grpclib.const.Cardinality.UNARY_UNARY,
                GeometryRequest,
                GeometryResponse,
            ),
        }


class OrderServiceBase(ServiceBase):

    async def price(self, price_request: "PriceRequest") -> "PriceResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_price(
        self, stream: "grpclib.server.Stream[PriceRequest, PriceResponse]"
    ) -> None:
        request = await stream.recv_message()
        response = await self.price(request)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/kerfed.protos.api.v1.OrderService/Price": grpclib.const.Handler(
                self.__rpc_price,
                grpclib.const.Cardinality.UNARY_UNARY,
                PriceRequest,
                PriceResponse,
            ),
        }
