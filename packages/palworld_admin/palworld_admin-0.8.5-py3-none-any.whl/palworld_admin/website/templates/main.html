<!-- Base html for app -->
<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{% block title %}Palworld ADMIN{% endblock %}</title>
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
            rel="stylesheet"
        />
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css"
            rel="stylesheet"
        />
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.min.js"></script>
        <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
        <script
            type="text/javascript"
            src="https://cdn.jsdelivr.net/npm/socket.io-client@4.7.4/dist/socket.io.min.js"
        ></script>
        <style>
            html {
                overflow: hidden;
            }
            /* Custom styles for the chevron button */
            .btn-custom-chevron {
                color: darkgray; /* Default color */
            }

            .btn-custom-chevron:hover {
                color: lightgray; /* Color on hover */
            }
            .content-div iframe {
                width: 96%;
                height: 80vh; /* Adjust height as needed */
                overflow: hidden;
                border: none;
            }
            .content-div {
                transition: transform 0.5s ease-in-out;
                position: absolute;
                width: 100%;
            }
            .slide-out-left {
                transform: translateX(-100%);
            }
            .slide-in-right {
                transform: translateX(100%);
            }
            .status-icon-wrapper {
                display: inline-flex; /* Allows the wrapper to be inline but also to transform */
                justify-content: center; /* Center the icon inside the wrapper */
                align-items: center; /* Align the icon vertically */
                transition: transform 0.5s ease-in-out; /* Smooth transition for rotation */
            }

            .flipped {
                transform: rotate(360deg); /* Rotate the wrapper 180 degrees */
            }
        </style>
    </head>
    <body class="rounded-bottom-1 border min-vh-100 d-flex flex-column">
        <!-- # Create a hamburger menu on the left side -->
        <nav class="navbar fixed-top rounded-top-1 border">
            <div class="row container-fluid d-flex justify-content-between">
                <!-- ... other nav elements ... -->
                <div class="col-4 d-flex align-items-center">
                    <!-- This div is for the hamburger menu and the title -->
                    <button
                        class="navbar-toggler"
                        type="button"
                        data-bs-toggle="offcanvas"
                        data-bs-target="#offcanvasNavbar"
                        aria-controls="offcanvasNavbar"
                        aria-label="Toggle navigation"
                    >
                        <span class="navbar-toggler-icon"></span>
                    </button>
                    <button
                        type="button"
                        class="btn btn-outline-secondary ms-3"
                        id="ServerBtn"
                        onclick="switchContent('localServerDiv')"
                    >
                        Server
                    </button>
                    <button
                        type="button"
                        class="btn btn-outline-secondary ms-3"
                        id="RCONBtn"
                        onclick="switchContent('RCONDiv')"
                    >
                        RCON
                    </button>
                </div>
                <div class="col-4 d-flex align-items-center">
                    <a class="navbar-brand mx-auto"></a>
                </div>
                <div
                    class="col-4 d-flex align-items-center justify-content-end me-0 pe-0"
                >
                    <!-- This div is for new minimize button and the close button -->
                    <!-- if value of webview passed in the dictionary webview_headers passed in jinja2 is true, then display buttons -->
                    {% if webview_headers.webview %}
                    <button
                        type="button"
                        class="btn btn-sm btn-custom-chevron"
                        aria-label="Minimize"
                        onclick="location.href='/minimize';"
                    >
                        <i class="bi bi-chevron-down"></i>
                    </button>
                    <button
                        type="button"
                        class="btn-close btn-close"
                        aria-label="Close"
                        onclick="location.href='/close';"
                    ></button>
                    {% endif %}
                </div>
                <div
                    class="offcanvas offcanvas-start"
                    tabindex="-1"
                    id="offcanvasNavbar"
                    aria-labelledby="offcanvasNavbarLabel"
                >
                    <div class="offcanvas-header">
                        <h5
                            class="offcanvas-title"
                            id="offcanvasDarkNavbarLabel"
                        >
                            Main Menu
                        </h5>
                        <button
                            type="button"
                            class="btn-close btn-close-white"
                            data-bs-dismiss="offcanvas"
                            aria-label="Close"
                        ></button>
                    </div>
                    <div class="offcanvas-body">
                        <ul
                            class="navbar-nav justify-content-end flex-grow-1 pe-3"
                        >
                            <li class="nav-item">
                                <a
                                    class="nav-link"
                                    data-target="#homeDiv"
                                    data-content="homeContent"
                                    href="#"
                                    onclick="switchContent('homeDiv')"
                                    >Home</a
                                >
                                <!-- <a
                                    class="nav-link active"
                                    aria-current="page"
                                    href="/"
                                    >Home</a
                                > -->
                            </li>
                            {% if management_mode == "local" %}
                            <li class="nav-item">
                                <a
                                    class="nav-link"
                                    data-target="#localServerDiv"
                                    data-content="localServerContent"
                                    href="#"
                                    onclick="switchContent('localServerDiv')"
                                    >Local Server Manager</a
                                >
                                <!-- <a class="nav-link" href="/server-installer"
                                    >Local Server Manager</a
                                > -->
                            </li>
                            {% else %}
                            <li class="nav-item">
                                <a
                                    class="nav-link"
                                    data-target="#localServerDiv"
                                    data-content="localServerContent"
                                    href="#"
                                    onclick="switchContent('localServerDiv')"
                                    >Remote Server Manager</a
                                >
                                <!-- <a class="nav-link" href="/server-installer"
                                    >Remote Server Manager</a
                                > -->
                            </li>
                            {% endif %}
                            <li class="nav-item">
                                <a
                                    class="nav-link"
                                    data-target="#RCONDiv"
                                    data-content="RCONContent"
                                    href="#"
                                    onclick="switchContent('RCONDiv')"
                                    >RCON</a
                                >
                                <!-- <a class="nav-link" href="/loadrcon">RCON</a> -->
                            </li>
                            <li class="nav-item">
                                <a
                                    class="nav-link"
                                    data-target="#settingsGenDiv"
                                    data-content="settingsGenContent"
                                    href="#"
                                    onclick="switchContent('settingsGenDiv')"
                                    >Settings Generator</a
                                >
                                <!-- <a class="nav-link" href="/settingsgen"
                                    >Settings Generator</a
                                > -->
                            </li>
                        </ul>
                    </div>
                    <div
                        class="offcanvas-footer text-muted p-3"
                        style="position: absolute; bottom: 0; width: 100%"
                    >
                        <div class="form-check form-switch">
                            <input
                                class="form-check-input text-end"
                                type="checkbox"
                                role="switch"
                                id="checkDarkMode"
                                checked
                            />
                            <label class="form-check-label" for="checkDarkMode"
                                >Dark Mode</label
                            >
                        </div>
                        <small>UI Version 0.8.0</small><br />
                        <small>Backend Version {{ version }}</small><br />
                        <small>Versions must match</small>
                    </div>
                </div>
            </div>
        </nav>
        <div class="container-fluid mt-5 ms-3 ps-0 me-5 pe-0">
            <div id="homeDiv" class="content-div ms-0 ps-0 me-0 pe-0">
                <!-- Home content iframe -->
                <iframe
                    src="/home"
                    frameborder="0"
                    id="homeIframe"
                    title="home"
                ></iframe>
            </div>
            <div
                id="localServerDiv"
                class="content-div ms-0 ps-0 me-0 pe-0"
                style="display: none"
                title="localServer"
            >
                <!-- Local Server Manager content iframe -->
                <iframe
                    src="/server-installer"
                    frameborder="0"
                    id="serverManagerIframe"
                ></iframe>
            </div>
            <div
                id="RCONDiv"
                class="content-div ms-0 ps-0 me-0 pe-0"
                style="display: none"
                title="RCON"
            >
                <!-- RCON content iframe -->
                <iframe src="/rcon" frameborder="0" id="RCONIframe"></iframe>
            </div>
            <div
                id="settingsGenDiv"
                class="content-div ms-0 ps-0 me-0 pe-0"
                style="display: none"
                title="settingsGen"
            >
                <!-- Settings Generator content iframe -->
                <iframe
                    src="/settingsgen"
                    frameborder="0"
                    id="settingsGenIframe"
                ></iframe>
            </div>
        </div>
        <!-- Textarea for displaying command outputs -->
        <div
            class="container-fluid ms-2 ps-1 pe-4"
            id="commandOutputContainer"
            style="
                height: 200px;
                resize: none;
                position: absolute;
                bottom: 160px;
                resize: none;
                display: none;
            "
        >
            <textarea
                id="commandOutput"
                class="form-control p-2"
                rows="8"
                placeholder="Command Output..."
                style="resize: none; overflow-y: auto; height: 100%"
                readonly
            ></textarea>
        </div>
        <!-- Confirmation Modal for Kick/Ban -->
        <div
            class="modal fade"
            id="actionConfirmationModal"
            tabindex="-1"
            aria-labelledby="actionConfirmationModalLabel"
            aria-hidden="true"
        >
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5
                            class="modal-title"
                            id="actionConfirmationModalLabel"
                        >
                            Confirm Action
                        </h5>
                        <button
                            type="button"
                            class="close"
                            data-dismiss="modal"
                            aria-label="Close"
                        >
                            <span aria-hidden="true">&times;</span>
                        </button>
                    </div>
                    <div class="modal-body">
                        Are you sure you want to <span id="actionType"></span>
                        <span id="actionPlayerName"></span>?
                    </div>
                    <div class="modal-footer">
                        <button
                            type="button"
                            class="btn btn-secondary"
                            data-dismiss="modal"
                        >
                            Cancel
                        </button>
                        <button
                            type="button"
                            class="btn btn-danger"
                            id="confirmAction"
                        >
                            Yes
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Install Confirmation Modal -->
        <div
            class="modal fade"
            id="installModal"
            tabindex="-1"
            aria-labelledby="installModalLabel"
            aria-hidden="true"
        >
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="modalTitle">
                            Confirm Action
                        </h5>
                        <button
                            type="button"
                            class="btn-close"
                            data-bs-dismiss="modal"
                            aria-label="Close"
                        ></button>
                    </div>
                    <div class="modal-body" id="modalBody">
                        <p id="modalText">
                            Are you sure you want to proceed with this action?
                        </p>
                        <p>
                            <strong id="modalStrongQuestion"
                                >This action cannot be undone.</strong
                            >
                        </p>
                    </div>
                    <div class="modal-footer">
                        <button
                            type="button"
                            class="btn btn-secondary"
                            data-bs-dismiss="modal"
                        >
                            Cancel
                        </button>
                        <button
                            type="button"
                            class="btn btn-primary"
                            id="modalConfirmBtn"
                        >
                            Confirm
                        </button>
                    </div>
                </div>
            </div>
        </div>
        <!-- Toast Notification -->
        <div aria-live="polite" aria-atomic="true" class="position-relative">
            <!-- Position it at the bottom right corner -->
            <div class="toast-container position-fixed bottom-0 end-0 p-3">
                <!-- Toast -->
                <div class="toast" id="copyToast">
                    <div class="toast-header">
                        <strong class="me-auto" id="toastTitle"
                            >Notification</strong
                        >
                        <button
                            type="button"
                            class="btn-close"
                            data-bs-dismiss="toast"
                            aria-label="Close"
                        ></button>
                    </div>
                    <div class="toast-body">
                        <!-- The message will be set by the JavaScript function -->
                    </div>
                </div>
            </div>
        </div>

        <footer
            class="footer mt-auto rounded-top-1 border"
            style="min-height: 150px; max-height: 150px"
        >
            <!-- Footer content -->
            <div
                class="container-fluid mt-0 ms-0 ps-0 me-0 pe-0 rounded border"
                style="position: absolute; bottom: 0; right: 0"
            >
                <div
                    class="container-fluid small text-sm-center text-secondary border-bottom"
                >
                    <div class="row">
                        <div class="col-1">OS</div>
                        <div class="col-1">Steam</div>
                        <div class="col-1">Server</div>
                        <div class="col-1">Version</div>
                        <div class="col-1">|</div>
                        <div class="col-1">I/O</div>
                        <div class="col-1">RCON</div>
                        <div class="col-1">UP</div>
                        <div class="col-1">|</div>
                        <div class="col-1">Players</div>
                        <div class="col-1">CPU(%)</div>
                        <div class="col-1">RAM(G)</div>
                    </div>
                </div>
                <div
                    class="container-fluid mt-0"
                    style="min-height: 25px; max-height: 25px; overflow: hidden"
                >
                    <div class="row text-center" id="installStatus">
                        <div class="col-1" id="statusOS"></div>
                        <div class="col-1" id="statusSteam"></div>
                        <div class="col-1" id="statusServer"></div>
                        <div class="col-1" id="statusVersion"></div>
                        <div class="col-1"></div>
                        <div class="col-1">
                            <div
                                id="statusIOWrapper"
                                class="status-icon-wrapper"
                            >
                                <i id="statusIO"></i>
                            </div>
                        </div>
                        <div class="col-1">
                            <div
                                id="statusRCONWrapper"
                                class="status-icon-wrapper"
                            >
                                <i id="statusRCON"></i>
                            </div>
                        </div>
                        <div class="col-1">
                            <div
                                id="statusUPWrapper"
                                class="status-icon-wrapper"
                            >
                                <i id="statusUP"></i>
                            </div>
                        </div>
                        <div class="col-1"></div>
                        <div class="col-1" id="statusPlayers"></div>
                        <div class="col-1" id="statusCPU"></div>
                        <div class="col-1" id="statusRAM"></div>
                    </div>
                </div>
            </div>
        </footer>
    </body>
    <script>
        ////////////////// Global Constants & Variables //////////////////
        const darkModeChecked = document.getElementById("checkDarkMode");

        const commandOutputContainer = document.getElementById(
            "commandOutputContainer"
        );
        const commandOutput = document.getElementById("commandOutput");
        const contentDivsWithOutput = ["localServerDiv", "RCONDiv"];

        const statusOS = document.getElementById("statusOS");
        const statusSteam = document.getElementById("statusSteam");
        const statusServer = document.getElementById("statusServer");
        const statusVersion = document.getElementById("statusVersion");

        const statusIOWrapper = document.getElementById("statusIOWrapper");
        const statusRCONWrapper = document.getElementById("statusRCONWrapper");
        const statusUPWrapper = document.getElementById("statusUPWrapper");
        const statusIO = document.getElementById("statusIO");
        const statusRCON = document.getElementById("statusRCON");
        const statusUP = document.getElementById("statusUP");

        const statusPlayers = document.getElementById("statusPlayers");
        const statusCPU = document.getElementById("statusCPU");
        const statusRAM = document.getElementById("statusRAM");

        const flashDelay = 500; // Delay in milliseconds for flashing elements
        const monitoringDelay = 2000; // RCON Monitoring delay in milliseconds
        const serverMonitoringDelay = 10000; // Server monitoring delay in milliseconds

        let currentAction = null; // Variable to hold the current action being performed

        let homeFrame;
        let serverManagerFrame;
        let RCONFrame;
        let settingsGenFrame;

        //////////////// Start Server Manager Variables //////////////////

        //////// GUI Elements ////////

        // Top Row Buttons
        let installBtn;
        let backupBtn;
        let restoreBtn;
        let uninstallBtn;

        // Server Settings Variables
        let updateSettingsBtn;
        let serverName;
        let serverPassword;
        let serverDescription;
        let serverMaxPlayers;
        let serverLocalIP;
        let serverPublicIP;
        let serverPort;
        let rconEnabledSelect;
        let adminPassword;
        let rconPort;
        let serverManagerFootnote;

        // Server Launcher Varibles
        let launchBtn;
        let stopServerBtn; // TODO
        let restartServerBtn;
        let epicApp;
        let useperfthreads;
        let NoAsyncLoadingThread;
        let UseMultithreadForDS;
        let launchRCON;
        let autoBackup;
        let backupInterval; // Time in seconds between automatic backups
        let backupCount;
        let checkAutoRestartTriggers;
        let autoRestartRAMTrigger;

        //////// Internal Variables ////////

        let userOS = "";
        let userOSIcon = "";
        let steamcmd_installed = false;
        let steamcmdIcon = "";
        let palserver_installed = false;
        let palserverIcon = "";
        let serverCommunicating = false; // Set communicating status to false
        let nextBackupTime = ""; // Stores the next backup time
        let serverRunning = false; // Set server running status to false
        let initialServerCheck = false; // Set initial server check status to false
        let rconUILoaded = false; // Set RCON UI loaded status to false
        let serverRunningOnStartup = false; // Set server running on startup status to false
        let serverRunningCheckCount = 0; // Set server check count to 0

        let ramCapTriggerCount = 0; // Set RAM cap trigger count to 0
        let ramCapTriggered = false; // Set RAM cap triggered status to false

        let serverRestartInitiated = false; // Set server restart initiated status to false

        let serverExpectedToBeRunning = false; // Set server expected to be running status to false

        let IOflashInterval; // Interval ID for the flashing elements
        let UPflashInterval; // Interval ID for the flashing elements
        let ServerMonitoringInterval; // Interval ID for the server monitoring

        let operationMessages = {
            first_run: {
                startup: "First Run Started...",
                success: "First Run Completed Successfully!",
                error: "First Run Failed.",
                exception:
                    "An error occurred while running the server for the first time.",
            },
            install_server: {
                startup: "Installing Server...",
                success: "Server installed successfully!",
                error: "Server failed to install.",
                exception: "An error occurred during server installation.",
            },
            start_server: {
                startup: "Starting Server...",
                success: "Server started successfully!",
                error: "Server failed to start.",
                exception: "An error occurred during server start.",
            },
            update_settings: {
                startup: "Updating Server Settings...",
                success: "Server settings updated successfully!",
                error: "Server settings failed to update.",
                exception: "An error occurred while updating server settings.",
            },
            backup_server: {
                startup: "Backing up Server...",
                success: "Server backed up successfully!",
                error: "Server failed to backup.",
                exception: "An error occurred while backing up the server.",
            },
            check_server_running: {
                error: "Server is not running.",
                exception: "An error occurred while checking server status.",
            },
        };

        //////////////// End Server Manager Variables //////////////////

        //////////////// Start RCON Variables //////////////////

        let RCONIpAddress;
        let RCONPort;
        let RCONPassword;
        let RCONConnectBtn;
        let RCONConnectForm;

        let RCONPlayersList;

        let RCONBroadcastMessage;
        let RCONBroadcastBtn;

        let RCONSaveBtn;
        let RCONShutdownMessage;
        let RCONShutdownDelay;
        let RCONShutdownBtn;

        //////// Internal Variables ////////

        let RCONConnected = false;
        let RCONCommunicating = false;
        let RCONMonitoringInterval;
        let RCONFlashInterval; // Interval ID for the flashing elements
        let lastPlayerList = []; // Stores the last known player list
        let playerVisibilityStates = {}; // Stores the visibility state of player info
        let lastPlayerDetails = {}; // Stores the last known details for each player

        //////////////// End RCON Variables //////////////////

        async function setupSettingsGenInteractions() {
            if (window.settingsGenFrame) {
                settingsGenFrame =
                    window.settingsGenFrame.getElementById("htmldoc");
            }
        }

        async function setupHomeInteractions() {
            if (window.homeFrame) {
                homeFrame = window.homeFrame.getElementById("htmldoc");
            }
        }

        async function setupRCONInteractions() {
            if (window.RCONFrame) {
                // Assign the RCON buttons and inputs to variables
                RCONFrame = window.RCONFrame.getElementById("htmldoc");
                RCONIpAddress = window.RCONFrame.getElementById("rconIPInput");
                RCONPort = window.RCONFrame.getElementById("rconPortInput");
                RCONPassword =
                    window.RCONFrame.getElementById("rconPasswordInput");
                RCONConnectBtn =
                    window.RCONFrame.getElementById("rconConnectBtn");
                RCONConnectForm = window.RCONFrame.getElementById("rconForm");

                RCONPlayersList =
                    window.RCONFrame.getElementById("playersList");

                RCONBroadcastMessage = window.RCONFrame.getElementById(
                    "broadcastMessageInput"
                );
                RCONBroadcastBtn =
                    window.RCONFrame.getElementById("broadcastBtn");

                RCONSaveBtn = window.RCONFrame.getElementById("saveBtn");
                RCONShutdownMessage = window.RCONFrame.getElementById(
                    "shutdownMessageInput"
                );
                RCONShutdownDelay =
                    window.RCONFrame.getElementById("shutdownDelayInput");
                RCONShutdownBtn =
                    window.RCONFrame.getElementById("shutdownBtn");

                storedSettings = await getDefaultStoredSettings("Connection");

                RCONIpAddress.value = storedSettings.host;
                RCONPort.value = storedSettings.port;
                RCONPassword.value = storedSettings.password;

                RCONConnectForm.addEventListener("submit", function (e) {
                    e.preventDefault();

                    if (!RCONConnected) {
                        startFlashing(
                            statusRCONWrapper,
                            statusRCON,
                            "RCONflashInterval",
                            flashDelay
                        ); // Begin flashing when attempting to connect
                        RCONCommunicating = true; // Set communicating status to true
                        let formData = new FormData(this);
                        let object = {};
                        formData.forEach((value, key) => (object[key] = value));
                        let json = JSON.stringify(object);

                        fetch("/connect", {
                            method: "POST",
                            headers: {
                                "Content-Type": "application/json",
                            },
                            body: json,
                        })
                            .then((response) => response.json())
                            .then((data) => {
                                stopFlashing("RCONflashInterval", statusRCON); // Stop flashing after fetch operation is complete
                                RCONCommunicating = false; // Set communicating status to false
                                RCONConnected = data.status === "success";
                                statusVersion.textContent = RCONConnected
                                    ? data.server_version
                                    : "N/C";
                                sendOutputMessage(data.message);
                                // Start monitoring if connected
                                if (RCONConnected) {
                                    RCONMonitoringInterval = startMonitoring();
                                } else {
                                    stopMonitoring(RCONMonitoringInterval);
                                }
                            })
                            .catch((error) => {
                                console.error("Error:", error);
                                statusVersion.textContent = "N/C";
                                RCONConnected = false;
                            })
                            .finally(() => {
                                updateUIBasedOnConnectionStatus();
                            });
                    } else {
                        // Handle disconnection logic here
                        stopMonitoring(RCONMonitoringInterval); // Stop monitoring if connected
                        stopFlashing("RCONflashInterval", statusRCON); // Stop flashing as we are manually setting to disconnected
                        RCONConnected = false;
                        statusVersion.textContent = "N/C";
                        statusPlayers.textContent = "N/C";
                        sendOutputMessage("Disconnected from the server.");
                        updateUIBasedOnConnectionStatus();
                    }
                    rconUILoaded = true;
                });

                // Function to handle the broadcast message sending
                RCONBroadcastBtn.addEventListener("click", function (e) {
                    e.preventDefault(); // Prevent form from submitting the traditional way
                    startFlashing(
                        statusRCONWrapper,
                        statusRCON,
                        "RCONflashInterval",
                        flashDelay
                    ); // Begin flashing when attempting to broadcast
                    RCONCommunicating = true; // Set communicating status to true

                    // Reuse the connection info and add the broadcast message
                    let ip = RCONIpAddress.value;
                    let port = RCONPort.value;
                    let password = RCONPassword.value;
                    let message = RCONBroadcastMessage.value;

                    // Prepare the data as JSON
                    let data = { ip, port, password, message };
                    let json = JSON.stringify(data);

                    // AJAX request to the Flask backend for broadcasting
                    fetch("/broadcast", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: json,
                    })
                        .then((response) => response.json())
                        .then((data) => {
                            stopFlashing("RCONflashInterval", statusRCON); // Stop flashing after fetch operation is complete
                            RCONCommunicating = false; // Set communicating status to false
                            // Handle response
                            sendOutputMessage("Broadcasted: " + message);
                        })
                        .catch((error) => {
                            console.error("Error:", error);
                            document.getElementById("commandOutput").value +=
                                "Broadcast Error: An unexpected error occurred.\n";
                        });

                    // Optionally clear the broadcast message input after sending
                    RCONBroadcastMessage.value = "";
                });

                // Event delegation for kick and ban buttons
                RCONFrame.addEventListener("click", function (e) {
                    if (
                        e.target.matches(".kick-player") ||
                        e.target.matches(".ban-player")
                    ) {
                        const playerName =
                            e.target.getAttribute("data-playername");
                        const steamid = e.target.getAttribute("data-steamid");
                        const action = e.target.matches(".kick-player")
                            ? "kick"
                            : "ban";
                        showConfirmationModal(action, playerName, steamid);
                    }
                });

                RCONSaveBtn.addEventListener("click", await save);
                RCONShutdownBtn.addEventListener("click", await shutdown);

                updateUIBasedOnConnectionStatus();
            }
        }

        async function setupServerManagerInteractions() {
            if (window.serverManagerFrame) {
                serverManagerFrame =
                    window.serverManagerFrame.getElementById("htmldoc");
                // Assign the server manager buttons and inputs to variables
                installBtn =
                    window.serverManagerFrame.getElementById("installBtn");
                backupBtn =
                    window.serverManagerFrame.getElementById("backupBtn");
                restoreBtn =
                    window.serverManagerFrame.getElementById("restoreBtn");
                uninstallBtn =
                    window.serverManagerFrame.getElementById("uninstallBtn");

                updateSettingsBtn =
                    window.serverManagerFrame.getElementById(
                        "updateSettingsBtn"
                    );
                serverName =
                    window.serverManagerFrame.getElementById("serverNameInput");
                serverPassword = window.serverManagerFrame.getElementById(
                    "serverPasswordInput"
                );
                serverDescription = window.serverManagerFrame.getElementById(
                    "serverDescriptionInput"
                );
                serverMaxPlayers = window.serverManagerFrame.getElementById(
                    "serverMaxPlayersInput"
                );
                serverLocalIP =
                    window.serverManagerFrame.getElementById(
                        "serverLocalIPInput"
                    );
                serverPublicIP = window.serverManagerFrame.getElementById(
                    "serverPublicIPInput"
                );
                serverPort =
                    window.serverManagerFrame.getElementById("serverPortInput");
                rconEnabledSelect =
                    window.serverManagerFrame.getElementById(
                        "rconEnabledSelect"
                    );
                adminPassword =
                    window.serverManagerFrame.getElementById(
                        "adminPasswordInput"
                    );
                rconPort =
                    window.serverManagerFrame.getElementById("rconPortInput");

                serverManagerFootnote =
                    window.serverManagerFrame.getElementById("footnote");

                launchBtn =
                    window.serverManagerFrame.getElementById("launchBtn");
                stopServerBtn =
                    window.serverManagerFrame.getElementById("stopServerBtn");
                restartServerBtn =
                    window.serverManagerFrame.getElementById(
                        "restartServerBtn"
                    );
                epicApp =
                    window.serverManagerFrame.getElementById(
                        "checkEnableEpicApp"
                    );
                useperfthreads = window.serverManagerFrame.getElementById(
                    "checkuseperfthreads"
                );
                NoAsyncLoadingThread = window.serverManagerFrame.getElementById(
                    "checkNoAsyncLoadingThread"
                );
                UseMultithreadForDS = window.serverManagerFrame.getElementById(
                    "checkUseMultithreadForDS"
                );
                launchRCON =
                    window.serverManagerFrame.getElementById(
                        "checkSwitchToRCON"
                    );
                autoBackup =
                    window.serverManagerFrame.getElementById("checkAutoBackup");
                backupInterval = window.serverManagerFrame.getElementById(
                    "serverAutoBackupIntervalInput"
                );
                backupCount = window.serverManagerFrame.getElementById(
                    "serverAutoBackupQuantityInput"
                );

                checkAutoRestartTriggers =
                    window.serverManagerFrame.getElementById(
                        "checkAutoRestartTriggers"
                    );
                autoRestartRAMTrigger =
                    window.serverManagerFrame.getElementById(
                        "serverAutoRestartRamInput"
                    );

                autoRestartRAMTrigger.value = 0.0;

                adminPassword.addEventListener("input", function () {
                    checkPasswordSecurity(adminPassword);
                });

                // Event listener for the installation button
                installBtn.addEventListener("click", function () {
                    currentAction = "installServer";
                    configureAndShowModal(
                        "Confirm Action",
                        "Are you sure you want to proceed with this action?",
                        "This action cannot be undone.",
                        "Confirm",
                        installServer
                    );
                });

                backupBtn.addEventListener("click", function () {
                    backupServer("manual");
                });

                // Event listener for the update settings button
                updateSettingsBtn.addEventListener("click", function () {
                    updatedServerSettings();
                });

                restartServerBtn.addEventListener("click", function () {
                    restartServer();
                });

                // Event listener for the start server button
                launchBtn.addEventListener("click", function () {
                    startServer();
                });

                storedSettings = await getDefaultStoredSettings(
                    "LauncherSettings"
                );
                console.log("Stored Settings: ", storedSettings);

                epicApp.checked = storedSettings.epicApp;
                useperfthreads.checked = storedSettings.useperfthreads;
                NoAsyncLoadingThread.checked =
                    storedSettings.NoAsyncLoadingThread;
                UseMultithreadForDS.checked =
                    storedSettings.UseMultithreadForDS;
                launchRCON.checked = storedSettings.launch_rcon;
                autoBackup.checked = storedSettings.auto_backup;
                backupInterval.value = storedSettings.auto_backup_delay;
                backupCount.value = storedSettings.auto_backup_quantity;
                checkAutoRestartTriggers.checked =
                    storedSettings.auto_restart_triggers;
                autoRestartRAMTrigger.value =
                    storedSettings.ram_restart_trigger;
            }
        }

        function setupIframeListeners() {
            // List of iframe IDs and the global variable names you want to assign their documents to
            const iframesInfo = [
                { id: "homeIframe", varName: "homeFrame" },
                { id: "serverManagerIframe", varName: "serverManagerFrame" },
                { id: "RCONIframe", varName: "RCONFrame" },
                { id: "settingsGenIframe", varName: "settingsGenFrame" },
            ];

            iframesInfo.forEach((iframeInfo) => {
                const iframe = document.getElementById(iframeInfo.id);
                if (!iframe) return; // Skip if the iframe doesn't exist

                iframe.onload = async () => {
                    // Using window[variableName] to dynamically assign properties to the window object
                    window[iframeInfo.varName] = iframe.contentWindow.document;

                    if (iframeInfo.varName === "RCONFrame") {
                        setupRCONInteractions();
                    }

                    if (iframeInfo.varName === "serverManagerFrame") {
                        await setupServerManagerInteractions();
                        await checkServerRunning();
                        await checkInstall();
                    }

                    if (iframeInfo.varName === "homeFrame") {
                        await setupHomeInteractions();
                    }

                    if (iframeInfo.varName === "settingsGenFrame") {
                        await setupSettingsGenInteractions();
                    }

                    // Optional: Call a function to perform additional setup or interactions with the iframe
                    // Example: setupRCONFrameInteractions();
                };
                switchDarkMode();
            });
        }

        document.addEventListener("DOMContentLoaded", function () {
            setupIframeListeners();
        });

        // Function to send output messages to the textarea
        function sendOutputMessage(message) {
            const now = new Date();
            const timestamp = now.toLocaleString(); // Adjust date format to your preference
            const formattedMessage = `[${timestamp}] ${message}\n`;
            commandOutput.value += formattedMessage;
            commandOutput.scrollTop = commandOutput.scrollHeight;
        }

        // Function to show toast notifications
        function showToast(message) {
            const toastBody = document.querySelector(".toast-body");
            toastBody.textContent = message;
            const toast = new bootstrap.Toast(
                document.getElementById("copyToast")
            );
            toast.show();
        }

        // Function to configure and show the confirmation modal
        function configureAndShowModal(
            title,
            bodyText,
            strongQuestion,
            confirmButtonText,
            onConfirm
        ) {
            document.getElementById("modalTitle").textContent = title;
            document.getElementById("modalText").textContent = bodyText;
            document.getElementById("modalStrongQuestion").textContent =
                strongQuestion;
            document.getElementById("modalConfirmBtn").textContent =
                confirmButtonText;

            const confirmBtn = document.getElementById("modalConfirmBtn");
            // Remove existing event listeners
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            // Add new event listener for the confirmation action
            newConfirmBtn.addEventListener("click", () => {
                onConfirm();
                $("#installModal").modal("hide"); // Hide modal after confirmation
            });

            $("#installModal").modal("show"); // Show the modal
        }

        function startFlashing(
            wrapperElement,
            iconElement,
            intervalVarName,
            flashDelay
        ) {
            // Reset the rotation to ensure it starts from the same direction every time
            // wrapperElement.style.transform = "rotate(0deg)";

            // Immediately apply the first rotation to ensure it starts in the desired direction
            wrapperElement.classList.add("flipped");

            // Clear any existing interval to prevent duplicates
            if (window[intervalVarName]) {
                clearInterval(window[intervalVarName]);
            }

            // Change the icon class
            iconElement.className = "bi bi-circle-half flip"; // Set to flashing icon

            // Start a new interval for the rotation
            window[intervalVarName] = setInterval(() => {
                // Toggle the flipped class on the wrapper to rotate the icon
                if (wrapperElement.classList.contains("flipped")) {
                    wrapperElement.classList.remove("flipped");
                } else {
                    wrapperElement.classList.add("flipped");
                }
            }, flashDelay); // Flash every specified delay
        }

        // Define a generic function to stop flashing
        function stopFlashing(
            intervalVarName,
            statusElement,
            finalStatusClass = "bi bi-circle-fill"
        ) {
            clearInterval(window[intervalVarName]); // Stop flashing
            statusElement.className = finalStatusClass; // Set to final status class
            statusElement.classList.remove("flipped"); // Ensure flipped class is removed
        }

        async function interactWithDatabase(
            functionName,
            { requestData = {} } = {}
        ) {
            const url = "/query-db"; // Endpoint URL
            const dataToSend = {
                function: functionName,
                ...(requestData && { data: requestData }), // Conditionally add requestData if it's not empty
            };

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(dataToSend), // Stringify the entire object
                });
                const data = await response.json();
                return data; // Directly return the data from the backend
            } catch (error) {
                console.error("Error:", error);
                // Construct and return an error object in a consistent format
                return {
                    status: "error",
                    message: "An error occurred: " + error.message,
                };
            }
        }

        async function getDefaultStoredSettings(dbTable) {
            const requestData = {
                model: dbTable,
            };

            const data = await interactWithDatabase("get_default_settings", {
                requestData,
            });
            return data;
        }

        async function interactWithBackend(
            functionName,
            { requestData = {} } = {}
        ) {
            const url = "/server-installer-cmd"; // Endpoint URL
            const dataToSend = {
                function: functionName,
                ...(requestData && { data: requestData }), // Conditionally add requestData if it's not empty
            };

            try {
                const response = await fetch(url, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(dataToSend), // Stringify the entire object
                });
                const data = await response.json();
                return data; // Directly return the data from the backend
            } catch (error) {
                console.error("Error:", error);
                // Construct and return an error object in a consistent format
                return {
                    status: "error",
                    message: "An error occurred: " + error.message,
                };
            }
        }

        async function handleBackendOperation(
            operation,
            {
                requestData = {},
                flashIO = false,
                flashUP = false,
                additionalLogic = () => {},
            } = {}
        ) {
            if (flashIO) {
                startFlashing(
                    statusIOWrapper,
                    statusIO,
                    "IOflashInterval",
                    flashDelay
                );
            }

            if (flashUP) {
                startFlashing(
                    statusUPWrapper,
                    statusUP,
                    "UPflashInterval",
                    flashDelay
                );
            }

            if (operationMessages[operation].startup) {
                sendOutputMessage(operationMessages[operation].startup);
            }

            try {
                const result = await interactWithBackend(operation, {
                    requestData,
                });
                if (result.status === "success") {
                    if (operationMessages[operation].success) {
                        sendOutputMessage(operationMessages[operation].success);
                        showToast(operationMessages[operation].success);
                    }
                } else {
                    sendOutputMessage(
                        operationMessages[operation].error || result.message
                    );
                    showToast(
                        operationMessages[operation].error || result.message
                    );
                }
                if (flashIO) {
                    stopFlashing("IOflashInterval", statusIO);
                }
                if (flashUP) {
                    stopFlashing("UPflashInterval", statusUP);
                }
                await additionalLogic(result);
            } catch (error) {
                console.error("Error:", error);
                sendOutputMessage(operationMessages[operation].exception);
                showToast(operationMessages[operation].exception);
            }
        }

        function switchContent(contentId) {
            const offcanvasElement = $("#offcanvasNavbar");
            const currentContent = $(".content-div:visible");
            const newContent = $("#" + contentId);

            if (currentContent.attr("id") === contentId) {
                // Don't animate if the selected content is already visible
                offcanvasElement.offcanvas("hide"); // Still close the menu
                return;
            }

            // Step 1: Start by closing the offcanvas menu
            offcanvasElement.offcanvas("hide");

            // Step 2: Wait for the offcanvas to hide before starting the content animation
            setTimeout(() => {
                // Slide out current content
                currentContent.addClass("slide-out-left");

                // Prepare new content off-screen
                newContent.addClass("slide-in-right").show();

                // Use requestAnimationFrame to ensure the browser has repainted after the initial setup
                requestAnimationFrame(() => {
                    // Step 3: After ensuring the new content is off-screen, start sliding it in
                    // Another requestAnimationFrame to ensure layout validity
                    requestAnimationFrame(() => {
                        newContent.removeClass("slide-in-right"); // Begin sliding in

                        // Step 4: After the animation is complete, hide the old content
                        // This delay should match or slightly exceed the CSS transition duration
                        setTimeout(() => {
                            currentContent.hide().removeClass("slide-out-left");
                        }, 500); // Match this with the longest transition time in your CSS
                    });
                });
            }, 200); // This delay should account for the offcanvas close animation time
        }

        function switchContent(contentId) {
            const offcanvasElement = $("#offcanvasNavbar");
            const currentContent = $(".content-div:visible");
            const newContent = $("#" + contentId);

            if (currentContent.attr("id") === contentId) {
                // Don't animate if the selected content is already visible
                offcanvasElement.offcanvas("hide"); // Still close the menu
                return;
            }

            // Determine if the current and new content require the command output container
            const currentContentRequiresOutput = contentDivsWithOutput.includes(
                currentContent.attr("id")
            );
            const newContentRequiresOutput =
                contentDivsWithOutput.includes(contentId);

            // Determine the state based on command output container requirement
            let state;
            if (!currentContentRequiresOutput && newContentRequiresOutput) {
                state = 0; // No output to output = Slide up
            } else if (
                currentContentRequiresOutput &&
                !newContentRequiresOutput
            ) {
                state = 1; // Output to no output = Slide down
            } else {
                state = 2; // Either output to output or no output to no output = Do nothing
            }

            // Animate the output container based on the state
            if (state === 0) {
                // Slide up
                commandOutputContainer.style.transition =
                    "bottom 0.5s ease-in-out";
                commandOutputContainer.style.bottom = "160px"; // Adjust as per the original position
            } else if (state === 1) {
                // Slide down
                commandOutputContainer.style.transition =
                    "bottom 0.5s ease-in-out";
                commandOutputContainer.style.bottom = "-200px"; // Slide below the viewport
            }
            // Note: No action needed for state 2, as it does nothing

            // Proceed with existing content switch logic
            offcanvasElement.offcanvas("hide");
            setTimeout(() => {
                currentContent.addClass("slide-out-left");
                newContent.addClass("slide-in-right").show();

                requestAnimationFrame(() => {
                    requestAnimationFrame(() => {
                        newContent.removeClass("slide-in-right");
                        setTimeout(() => {
                            currentContent.hide().removeClass("slide-out-left");
                        }, 500);
                    });
                });
            }, 200);
        }

        const checkPasswordSecurity = (inputElement) => {
            const value = inputElement.value;

            if (value.length < 8) {
                // If not, highlight the field and show the footnote
                inputElement.classList.add("is-invalid"); // Use Bootstrap's is-invalid class for highlighting
                serverManagerFootnote.style.display = "block";
                updateSettingsBtn.disabled = true;
                launchBtn.disabled = true;
            } else {
                // If it is, remove any highlights
                inputElement.classList.remove("is-invalid");
                serverManagerFootnote.style.display = "none";
                updateSettingsBtn.disabled = false;
                launchBtn.disabled = false;
            }
        };

        function sleep(ms) {
            return new Promise((resolve) => setTimeout(resolve, ms));
        }

        async function checkInstall() {
            console.log("Waiting for initial server check to complete...");
            while (!initialServerCheck) {
                await sleep(1000); // Wait for 1 second before checking again
            }
            console.log(
                "Initial server check complete, proceeding with checkInstall..."
            );

            const requestData = JSON.stringify({
                function: "check_install",
            });

            const response = await fetch("/server-installer-cmd", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: requestData,
            })
                .then((response) => response.json())
                .then((data) => {
                    console.log(data);
                    if (data.status === "success") {
                        if (data.os.value === "Windows") {
                            userOS = "Windows";
                            userOSIcon = "bi bi-windows";
                        } else if (data.os.value === "Linux") {
                            userOS = "Linux";
                            userOSIcon = "bi bi-ubuntu";
                        } else if (data.os.value === "Darwin") {
                            userOS = "MacOS";
                            userOSIcon = "bi bi-apple";
                        } else {
                            userOS = "Unknown";
                            userOSIcon = "bi bi-question";
                        }
                        if (data.steamcmd.value === true) {
                            steamcmd_installed = true;
                            steamcmdIcon = "bi bi-check-circle";
                        } else {
                            steamcmd_installed = false;
                            steamcmdIcon = "bi bi-x-circle";
                        }
                        if (data.palserver.value === true) {
                            palserver_installed = true;
                            palserverIcon = "bi bi-check-circle";
                            backupBtn.disabled = false;
                        } else {
                            palserver_installed = false;
                            palserverIcon = "bi bi-x-circle";
                        }

                        statusOS.innerHTML = `<i class="${userOSIcon}"></i>`;
                        statusSteam.innerHTML = `<i class="${steamcmdIcon}"></i>`;
                        statusServer.innerHTML = `<i class="${palserverIcon}"></i>`;
                        statusIO.className = "bi bi-circle-fill";

                        console.log(data.settings);

                        serverName.value = data.settings.settings.ServerName;
                        serverPassword.value =
                            data.settings.settings.ServerPassword;
                        serverDescription.value =
                            data.settings.settings.ServerDescription;
                        serverMaxPlayers.value =
                            data.settings.settings.ServerPlayerMaxNum;

                        serverPort.value = data.settings.settings.PublicPort;

                        rconPort.value = data.settings.settings.RCONPort;
                        adminPassword.value =
                            data.settings.settings.AdminPassword;

                        if (data.settings.settings.RCONEnabled === "True") {
                            rconEnabledSelect.value = true;
                        } else {
                            rconEnabledSelect.value = false;
                        }

                        serverName.disabled = false;
                        serverPassword.disabled = false;
                        serverDescription.disabled = false;
                        serverMaxPlayers.disabled = false;
                        serverLocalIP.disabled = false;
                        serverPublicIP.disabled = false;
                        serverPort.disabled = false;
                        rconPort.disabled = false;
                        adminPassword.disabled = false;
                        serverLocalIP.value = data.settings.settings.LocalIP;
                        serverPublicIP.value = data.settings.settings.PublicIP;

                        const valuesRemoveQuotes = [
                            serverName,
                            serverPassword,
                            serverDescription,
                            adminPassword,
                            serverPublicIP,
                        ];

                        valuesRemoveQuotes.forEach((input) => {
                            if (
                                input.value.startsWith('"') &&
                                input.value.endsWith('"')
                            ) {
                                input.value = input.value.slice(1, -1);
                            }
                        });

                        updateSettingsBtn.disabled = false;

                        launchBtn.disabled = false;

                        epicApp.disabled = false;
                        useperfthreads.disabled = false;
                        NoAsyncLoadingThread.disabled = false;
                        UseMultithreadForDS.disabled = false;

                        launchRCON.disabled = false;
                        autoBackup.disabled = false;

                        backupInterval.disabled = false;
                        backupCount.disabled = false;

                        checkAutoRestartTriggers.disabled = false;
                        autoRestartRAMTrigger.disabled = false;

                        operationMessages.install_server.startup =
                            palserver_installed
                                ? "PalServer already installed. Updating..."
                                : "Installing PalServer...";
                        operationMessages.install_server.success =
                            palserver_installed
                                ? "PalServer updated successfully!"
                                : "PalServer installed successfully!";
                        operationMessages.install_server.error =
                            palserver_installed
                                ? "PalServer failed to update."
                                : "PalServer failed to install.";
                        operationMessages.install_server.exception =
                            palserver_installed
                                ? "An error occurred while updating PalServer."
                                : "An error occurred during PalServer installation.";

                        console.log("The server is running: " + serverRunning);
                        if (serverRunningOnStartup === true) {
                            if (launchRCON.checked) {
                                RCONIpAddress.value = serverLocalIP.value;
                                RCONPort.value = rconPort.value;
                                RCONPassword.value = adminPassword.value;
                                showToast(
                                    "Server is already running. Monitoring started and RCON connection will be attempted in 5 seconds..."
                                );
                                // Wait 5 seconds before attempting to connect to the server
                                setTimeout(() => {
                                    RCONConnectForm.dispatchEvent(
                                        new Event("submit")
                                    );
                                    switchContent("RCONDiv");
                                }, 5000);
                            } else {
                                showToast(
                                    "Server is already running. Starting Monitoring..."
                                );
                            }
                            ServerMonitoringInterval = startMonitoringServer();
                        }

                        return data;
                    } else {
                        statusOS.textContent = "Error";
                        statusSteam.textContent = "Error";
                        statusServer.textContent = "Error";
                        statusIO.className = "bi bi-circle";
                        return data;
                    }
                })
                .catch((error) => {
                    console.error("Error:", error);
                });
        }

        // Permanent event listener for the confirmation action
        modalConfirmBtn.addEventListener("click", function () {
            if (currentAction) {
                window[currentAction](); // Execute the function based on currentAction
            }
            $("#installModal").modal("hide"); // Hide modal after confirmation
        });

        window.installServer = async function () {
            const additionalLogic = () => {
                checkInstall();
            };
            handleBackendOperation("install_server", {
                flashIO: true,
                additionalLogic,
            });
        };

        async function backupServer(backupType = "manual") {
            const requestData = {
                backup_type: backupType,
                backup_count: backupCount.value,
            };

            handleBackendOperation("backup_server", {
                requestData,
                flashIO: true,
            });
        }

        async function firstRun() {
            handleBackendOperation("first_run");
        }

        async function updatedServerSettings() {
            updateSettingsBtn.disabled = false;
            launchBtn.disabled = false;

            const valuesAddQuotes = [
                serverName,
                serverPassword,
                serverDescription,
                adminPassword,
            ];

            valuesAddQuotes.forEach((input) => {
                if (
                    !input.value.startsWith('"') &&
                    !input.value.endsWith('"')
                ) {
                    input.value = `"${input.value}"`;
                }
            });

            const additionalLogic = (result) => {
                if (result.status === "success") {
                    updateSettingsBtn.disabled = false;
                    launchBtn.disabled = false;
                    checkInstall();
                }
            };

            const requestData = {
                ServerName: serverName.value,
                ServerPassword: serverPassword.value,
                ServerDescription: serverDescription.value,
                ServerPlayerMaxNum: serverMaxPlayers.value,
                PublicPort: serverPort.value,
                RCONPort: rconPort.value,
                AdminPassword: adminPassword.value,
                RCONEnabled: rconEnabledSelect.value,
            };

            handleBackendOperation("update_settings", {
                requestData,
                flashIO: true,
                additionalLogic,
            });
        }

        function startMonitoringServer() {
            // Call checkServerRunning immediately in case you want the action to be taken right away
            checkServerRunning();

            const intervalId = setInterval(() => {
                // If the server is communicating with the backend, don't run the monitoring logic
                if (serverCommunicating) {
                    return;
                }

                // If the server is running and a restart has been initiated, stop monitoring
                if (serverRunning && serverRestartInitiated) {
                    sendOutputMessage(
                        "Server restart initiated. Stopping monitoring..."
                    );
                    stopMonitoring(ServerMonitoringInterval);
                    return;
                }

                // If auto-backup is enabled and the next backup time has been reached, initiate a backup
                if (autoBackup.checked && nextBackupTime <= new Date()) {
                    backupServer("auto");
                    nextBackupTime = new Date(
                        new Date().getTime() + backupInterval.value * 1000
                    );
                    console.log("Next Backup Time: " + nextBackupTime);
                }

                // If the server is running and the serverRunningCheckCount is greater than 3, check for auto-restart triggers
                if (
                    serverRunningCheckCount > 3 &&
                    checkAutoRestartTriggers.checked === true &&
                    autoRestartRAMTrigger.value > 0 &&
                    ramCapTriggered
                ) {
                    sendOutputMessage(
                        "Server RAM usage has exceeded the trigger value. Restarting server..."
                    );
                    restartServer();
                    return;
                }

                // If the server is not expected to be running and it's not, stop monitoring
                if (!serverRunning && !serverExpectedToBeRunning) {
                    sendOutputMessage(
                        "Server is not running. Stopping monitoring server status."
                    );
                    stopMonitoring(ServerMonitoringInterval);
                    return;
                }

                // If the server is expected to be running but it's not, attempt to start it
                if (!serverRunning && serverExpectedToBeRunning) {
                    sendOutputMessage(
                        "Server appears to have stopped. Attempting to start server..."
                    );
                    stopMonitoring(ServerMonitoringInterval);
                    startServer();
                    return;
                }

                checkServerRunning();
            }, serverMonitoringDelay);

            return intervalId;
        }

        async function checkServerRunning() {
            const additionalLogic = (result) => {
                console.log("checkServerRunning Result:", result);
                if (result.status === "success") {
                    console.log("Server Running: " + result.value);
                    if (result.value === true) {
                        const ramUsage = parseFloat(result.ram_usage);
                        let ramTriggerValue = parseFloat(
                            autoRestartRAMTrigger.value
                        );
                        if (isNaN(ramTriggerValue)) {
                            ramTriggerValue = 0;
                        }

                        launchBtn.disabled = true;
                        restartServerBtn.disabled = false;
                        serverRunning = true;
                        statusUP.className = "bi bi-circle-fill";
                        statusCPU.textContent = result.cpu_usage;
                        statusRAM.textContent = result.ram_usage;
                        // Check if the RAM usage has exceeded the trigger value and a trigger is set
                        console.log(
                            "RAM Usage: " +
                                ramUsage +
                                " GB - var type: " +
                                typeof ramUsage
                        );
                        console.log(
                            "RAM Trigger Value: " +
                                ramTriggerValue +
                                " GB - var type: " +
                                typeof ramTriggerValue
                        );
                        if (
                            ramUsage >= ramTriggerValue &&
                            ramTriggerValue > 0
                        ) {
                            console.log(
                                "RAM usage has exceeded the trigger value."
                            );
                            ramCapTriggerCount++;
                            sendOutputMessage(
                                "RAM Limit Trigger " +
                                    ramCapTriggerCount +
                                    " of 3 reached."
                            );
                            console.log(
                                "RAM Cap Trigger Count: " + ramCapTriggerCount
                            );
                        } else {
                            // Reset the trigger count if the RAM usage is below the trigger value
                            ramCapTriggerCount = 0;
                            ramCapTriggered = false;
                        }
                        if (ramCapTriggerCount >= 3) {
                            ramCapTriggered = true;
                        }
                    } else {
                        if (palserver_installed) {
                            launchBtn.disabled = false;
                        }

                        restartServerBtn.disabled = true;
                        serverRunning = false;
                        statusUP.className = "bi bi-circle";
                        statusCPU.textContent = "0";
                        statusRAM.textContent = "0";
                    }
                }

                if (serverRunningCheckCount === 0 && serverRunning === true) {
                    console.log(
                        "Server Running on Startup, setting serverRunningOnStartup and serverExpectedToBeRunning to true."
                    );
                    serverRunningOnStartup = true;
                    serverExpectedToBeRunning = true;
                }

                serverRunningCheckCount++;
                initialServerCheck = true;
            };
            handleBackendOperation("check_server_running", {
                flashUP: true,
                additionalLogic,
            });
        }

        async function restartServer() {
            if (RCONConnected) {
                sendOutputMessage("Server restart initiated...");
                serverRestartInitiated = true;
                const savedResult = await save();
                if (savedResult.status === "success") {
                    sendOutputMessage(
                        "Server Data saved for restart. Next, scheduling graceful shutdown for 10 seconds..."
                    );
                    RCONShutdownMessage.value = "Server Restarting in 10...";
                    RCONShutdownDelay.value = "10";
                    const shutdownResult = await shutdown();
                    setTimeout(() => {
                        if (shutdownResult.status === "success") {
                            sendOutputMessage(
                                "Server gracefully shut down. Creating a Manual Backup then restarting server in 5 seconds..."
                            );
                            backupResult = backupServer("manual");
                            setTimeout(() => {
                                serverRunningCheckCount = 0;
                                serverRestartInitiated = false;
                                ramCapTriggerCount = 0;
                                ramCapTriggered = false;
                                startServer();
                            }, 5000);
                        }
                    }, 15000);
                }
            }
        }

        async function startServer() {
            let autoBackupDelayValue = parseInt(backupInterval.value);
            let autoBackupQuantityValue = parseInt(backupCount.value);
            let autoRestartRAMTriggerValue = parseFloat(
                autoRestartRAMTrigger.value
            );
            if (
                adminPassword.value === "admin" &&
                rconEnabledSelect.value === "true"
            ) {
                showToast(
                    'Default password "admin" detected. Please change the password before starting the server.'
                );
                return;
            }

            if (serverRunning) {
                console.log("Server is already running.");
                return;
            }

            if (autoBackup.checked && backupCount.value < 1) {
                showToast("Automatic backups require a minimum quantity of 1.");
                return;
            }

            if (autoBackup.checked) {
                if (isNaN(autoBackupDelayValue)) {
                    showToast(
                        "Invalid value for backup interval. Please enter a valid number."
                    );
                    return;
                }
                if (isNaN(autoBackupQuantityValue)) {
                    showToast(
                        "Invalid value for backup quantity. Please enter a valid number."
                    );
                    return;
                }
                if (autoBackupDelayValue < 300) {
                    showToast(
                        "Automatic backups require a minimum interval of 5 minutes."
                    );
                    return;
                }
            }

            if (
                checkAutoRestartTriggers.checked &&
                isNaN(autoRestartRAMTriggerValue)
            ) {
                showToast(
                    "Invalid value for RAM trigger. Please enter a valid number."
                );
                return;
            }

            if (autoBackup.checked) {
                nextBackupTime = new Date(
                    new Date().getTime() + backupInterval.value * 1000
                );
                console.log("Next Backup Time: " + nextBackupTime);
            }

            const additionalLogic = (result) => {
                if (result.status === "success") {
                    launchBtn.disabled = true;
                    if (launchRCON.checked) {
                        RCONIpAddress.value = serverLocalIP.value;
                        RCONPort.value = rconPort.value;
                        RCONPassword.value = adminPassword.value;
                        sendOutputMessage(
                            "Starting RCON connection in 5 seconds..."
                        );
                        // Wait 5 seconds before attempting to connect to the server
                        setTimeout(() => {
                            RCONConnectForm.dispatchEvent(new Event("submit"));
                            switchContent("RCONDiv");
                        }, 5000);
                    }
                    serverExpectedToBeRunning = true;
                    // Wait 5 seconds before starting monitoring
                    setTimeout(() => {
                        ServerMonitoringInterval = startMonitoringServer();
                    }, 5000);
                }
            };

            const requestData = {
                launch_rcon: launchRCON.checked,
                epicApp: epicApp.checked,
                useperfthreads: useperfthreads.checked,
                NoAsyncLoadingThread: NoAsyncLoadingThread.checked,
                UseMultithreadForDS: UseMultithreadForDS.checked,
                auto_backup: autoBackup.checked,
                auto_backup_delay: backupInterval.value,
                auto_backup_quantity: backupCount.value,
                auto_restart_triggers: checkAutoRestartTriggers.checked,
                ram_restart_trigger: autoRestartRAMTriggerValue,
            };

            handleBackendOperation("start_server", {
                requestData,
                flashIO: true,
                additionalLogic,
            });
        }

        // Function to start monitoring
        function startMonitoring() {
            // Call the async function immediately in case you want the action to be taken right away
            fetchAndDisplayPlayersAsync();

            // Set up an interval to run the async function repeatedly
            const intervalId = setInterval(() => {
                if (RCONCommunicating) {
                    return;
                }
                if (!RCONConnected) {
                    sendOutputMessage(
                        "Connection to server lost. Disconnecting RCON."
                    );
                    updateUIBasedOnConnectionStatus();
                    stopMonitoring(RCONMonitoringInterval);
                    return;
                }
                fetchAndDisplayPlayersAsync();
            }, monitoringDelay);

            // Optional: Store the intervalId if you need to clear it later
            return intervalId;
        }

        // To stop monitoring, you can use clearInterval with the stored intervalId
        function stopMonitoring(intervalId) {
            clearInterval(intervalId);
        }

        async function broadcastMessage(message) {
            startFlashing(
                statusRCONWrapper,
                statusRCON,
                "RCONflashInterval",
                flashDelay
            ); // Begin flashing when attempting to broadcast
            RCONCommunicating = true; // Set communicating status to true

            // Reuse the connection info and add the broadcast message
            let ip = RCONIpAddress.value;
            let port = RCONPort.value;
            let password = RCONPassword.value;

            // Prepare the data as JSON
            let data = { ip, port, password, message };
            let json = JSON.stringify(data);

            // AJAX request to the Flask backend for broadcasting
            fetch("/broadcast", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: json,
            })
                .then((response) => response.json())
                .then((data) => {
                    stopFlashing("RCONflashInterval", statusRCON); // Stop flashing after fetch operation is complete
                    RCONCommunicating = false; // Set communicating status to false
                    // Handle response
                    sendOutputMessage("Broadcasted: " + message);
                })
                .catch((error) => {
                    console.error("Error:", error);
                    document.getElementById("commandOutput").value +=
                        "Broadcast Error: An unexpected error occurred.\n";
                });

            // Optionally clear the broadcast message input after sending
            RCONBroadcastMessage.value = "";
        }

        // Function to fetch and display players
        async function fetchAndDisplayPlayersAsync() {
            if (!RCONConnected) {
                RCONPlayersList.innerHTML =
                    '<div class="row"><div class="col">Please connect to the server first.</div></div>';
                return;
            }
            startFlashing(
                statusRCONWrapper,
                statusRCON,
                "RCONflashInterval",
                flashDelay
            ); // Begin flashing when attempting to fetch players
            RCONCommunicating = true; // Set communicating status to true

            const requestData = JSON.stringify({
                ip: RCONIpAddress.value,
                port: RCONPort.value,
                password: RCONPassword.value,
            });

            fetch("/getplayers", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: requestData,
            })
                .then((response) => response.json())
                .then((data) => {
                    stopFlashing("RCONflashInterval", statusRCON); // Stop flashing after fetch operation is complete
                    RCONCommunicating = false; // Set communicating status to false

                    if (data.status === "error") {
                        RCONConnected = false;
                        sendOutputMessage("Failed to fetch players.");
                        return;
                    }

                    // Clear existing player entries, keeping the header row
                    RCONPlayersList.innerHTML = "";

                    const currentPlayerSteamIds = data.players.map(
                        (player) => player.steamid
                    );

                    // Announce player joins
                    currentPlayerSteamIds.forEach((steamid) => {
                        if (!lastPlayerDetails[steamid]) {
                            sendOutputMessage(
                                `Player Joined - ${
                                    data.players.find(
                                        (p) => p.steamid === steamid
                                    ).name
                                }`
                            );
                            //broadcastMessage(
                            //    `Welcome to the server, ${
                            //        data.players.find(
                            //            (p) => p.steamid === steamid
                            //        ).name
                            //    }!`
                            //);
                        }
                    });

                    // Announce player leaves
                    Object.keys(lastPlayerDetails).forEach((steamid) => {
                        if (!currentPlayerSteamIds.includes(steamid)) {
                            sendOutputMessage(
                                `Player Left - ${lastPlayerDetails[steamid].name}`
                            );
                            //broadcastMessage(
                            //    `Goodbye, ${lastPlayerDetails[steamid].name}!`
                            //);
                        }
                    });

                    // Update player details and visibility states for current players
                    data.players.forEach((player) => {
                        const steamid = player.steamid;
                        const isVisible =
                            playerVisibilityStates[steamid] || false;
                        lastPlayerDetails[steamid] = {
                            ...player,
                            isVisible,
                        };

                        const playerRow = document.createElement("div");
                        playerRow.className = "row mt-1";

                        const uidDisplay = isVisible
                            ? player.playeruid
                            : "********";
                        const steamIdDisplay = isVisible
                            ? player.steamid
                            : "************";
                        const visibilityButtonText = isVisible ? "" : "";

                        playerRow.innerHTML = `
                        <div class="col">${player.name}</div>
                        <div class="col" id="uid-${steamid}">${uidDisplay}</div>
                        <div class="col" id="steamid-${steamid}">${steamIdDisplay}</div>
                        <div class="col">
                            <button class="btn btn-sm btn-outline-secondary visibility-toggle" data-steamid="${steamid}">${visibilityButtonText}</button>
                            <button class="btn btn-sm btn-outline-warning kick-player" data-steamid="${steamid}" data-playername="${player.name}" title="Kick Player"></button>
                            <button class="btn btn-sm btn-outline-danger ban-player" data-steamid="${steamid}" data-playername="${player.name}" title="Ban Player"></button
                        </div>
                    `;

                        RCONPlayersList.appendChild(playerRow);
                    });

                    // After appending all player rows, attach event listeners to the visibility toggle buttons
                    RCONFrame.querySelectorAll(".visibility-toggle").forEach(
                        (button) => {
                            button.addEventListener("click", function () {
                                const steamid =
                                    this.getAttribute("data-steamid");
                                const currentVisibility =
                                    playerVisibilityStates[steamid];
                                playerVisibilityStates[steamid] =
                                    !currentVisibility;

                                const uidElement = RCONFrame.getElementById(
                                    `uid-${steamid}`
                                );
                                const steamIdElement = RCONFrame.getElementById(
                                    `steamid-${steamid}`
                                );

                                uidElement.textContent = !currentVisibility
                                    ? lastPlayerDetails[steamid].playeruid
                                    : "********";
                                steamIdElement.textContent = !currentVisibility
                                    ? lastPlayerDetails[steamid].steamid
                                    : "************";
                                this.innerHTML = !currentVisibility
                                    ? ""
                                    : "";
                            });
                        }
                    );

                    // Remove details for players who have left
                    Object.keys(lastPlayerDetails).forEach((steamid) => {
                        if (!currentPlayerSteamIds.includes(steamid)) {
                            delete lastPlayerDetails[steamid];
                        }
                    });

                    // Update player count
                    statusPlayers.textContent = data.players.length.toString();
                })
                .catch((error) => {
                    console.error("Error fetching players:", error);
                    sendOutputMessage("Error fetching player list: " + error);
                })
                .finally(() => {
                    updateUIBasedOnConnectionStatus();
                });
        }

        // Function to enable or disable elemeents based on connection status
        function updateUIBasedOnConnectionStatus() {
            RCONIpAddress.disabled = RCONConnected;
            RCONPort.disabled = RCONConnected;
            RCONPassword.disabled = RCONConnected;

            RCONBroadcastMessage.disabled = !RCONConnected;
            RCONBroadcastBtn.disabled = !RCONConnected;
            RCONBroadcastMessage.placeholder = RCONConnected
                ? "Broadcast Message"
                : "Broadcast Message - Please Connect First!";

            RCONSaveBtn.disabled = !RCONConnected;
            RCONShutdownBtn.disabled = !RCONConnected;
            RCONShutdownMessage.disabled = !RCONConnected;
            RCONShutdownDelay.disabled = !RCONConnected;

            statusRCON.className = RCONConnected
                ? "bi bi-circle-fill"
                : "bi bi-circle";
            RCONConnectBtn.innerText = RCONConnected ? "Disconnect" : "Connect";
            RCONConnectBtn.classList.remove(
                RCONConnected ? "btn-success" : "btn-danger"
            );
            RCONConnectBtn.classList.add(
                RCONConnected ? "btn-danger" : "btn-success"
            );
            if (!RCONConnected) {
                RCONPlayersList.innerHTML = "";
                statusPlayers.textContent = "N/C";
                statusVersion.textContent = "N/C";
            }
        }

        // Function to handle the save button click
        async function save() {
            // Start flashing to indicate operation start
            startFlashing(
                statusRCONWrapper,
                statusRCON,
                "RCONflashInterval",
                flashDelay
            );
            RCONCommunicating = true; // Set communicating status to true

            const requestData = {
                ip: RCONIpAddress.value,
                port: RCONPort.value,
                password: RCONPassword.value,
            };

            try {
                // Using await to wait for the fetch to complete
                const response = await fetch("/save", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: JSON.stringify(requestData),
                });

                const data = await response.json(); // Wait for the JSON response

                // Handle success
                stopFlashing("RCONflashInterval", statusRCON); // Stop flashing
                RCONCommunicating = false; // Set communicating status to false

                sendOutputMessage(data.message); // Display message

                // Here you can return a dictionary based on the response data
                // For example, if you want to return a simple success status dictionary
                return { status: "success", data: data };
            } catch (error) {
                console.error("Error:", error);
                stopFlashing("RCONflashInterval", statusRCON); // Ensure flashing is stopped in case of error
                RCONCommunicating = false; // Ensure communicating flag is reset
                document.getElementById("commandOutput").value +=
                    "Save Error: An unexpected error occurred.\n";
                // Return or handle error dictionary as needed
                return {
                    status: "error",
                    message: "An unexpected error occurred.",
                };
            }
        }

        // Function to handle the shutdown button click
        async function shutdown() {
            serverExpectedToBeRunning = false;
            serverRunningCheckCount = 1; // Set to 1 because setting to 0 will trigger the serverRunningOnStartup condition

            startFlashing(
                statusRCONWrapper,
                statusRCON,
                "RCONflashInterval",
                flashDelay
            ); // Begin flashing when attempting to shutdown
            RCONCommunicating = true; // Set communicating status to true

            const requestData = JSON.stringify({
                ip: RCONIpAddress.value,
                port: RCONPort.value,
                password: RCONPassword.value,
                message: RCONShutdownMessage.value,
                delay: RCONShutdownDelay.value,
            });

            try {
                const response = await fetch("/shutdown", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                    },
                    body: requestData,
                });

                const data = await response.json(); // Wait for the JSON response

                // Handle success
                stopFlashing("RCONflashInterval", statusRCON); // Stop flashing
                RCONCommunicating = false; // Set communicating status to false
                sendOutputMessage(data.message); // Display message

                if (!serverRestartInitiated) {
                    checkServerRunning();
                    checkInstall();
                } else {
                    serverRunning = false;
                }

                // Here you can return a dictionary based on the response data
                return { status: "success", data: data };
            } catch (error) {
                console.error("Error:", error);
                stopFlashing("RCONflashInterval", statusRCON); // Ensure flashing is stopped in case of error
                RCONCommunicating = false; // Ensure communicating flag is reset
                document.getElementById("commandOutput").value +=
                    "Shutdown Error: An unexpected error occurred.\n";

                // Return or handle error dictionary as needed
                return {
                    status: "error",
                    message: "An unexpected error occurred.",
                };
            }
        }

        function toggleVisibility(steamid) {
            const isVisible = !playerVisibilityStates[steamid];
            playerVisibilityStates[steamid] = isVisible;

            // Directly update the UI elements for this player's visibility
            const uidElement = document.getElementById(`uid-${steamid}`);
            const steamIdElement = document.getElementById(
                `steamid-${steamid}`
            );
            const buttonElement = document.getElementById(`toggle-${steamid}`);

            if (isVisible) {
                // Assuming lastPlayerDetails[steamid] holds the latest player info
                uidElement.textContent = lastPlayerDetails[steamid].playeruid;
                steamIdElement.textContent = lastPlayerDetails[steamid].steamid;
                buttonElement.innerHTML = "";
            } else {
                uidElement.textContent = "********";
                steamIdElement.textContent = "************";
                buttonElement.innerHTML = "";
            }
        }

        function showConfirmationModal(action, playerName, steamid) {
            $("#actionType").text(action);
            $("#actionPlayerName").text(playerName);
            $("#confirmAction").data("action", action); // Store action for use in confirmation
            $("#confirmAction").data("steamid", steamid); // Store steamid for use in confirmation
            $("#actionConfirmationModal").modal("show");
        }

        // Handle modal confirmation button click
        $("#confirmAction").click(function () {
            const action = $(this).data("action");
            const steamid = $(this).data("steamid");
            const playerName = $("#actionPlayerName").text(); // Get the player name from the modal
            kickOrBanPlayer(action, playerName, steamid);
            $("#actionConfirmationModal").modal("hide");
        });

        function kickOrBanPlayer(action, playerName, steamid) {
            const url = action === "kick" ? "/kickplayer" : "/banplayer";
            const data = JSON.stringify({
                ip: RCONIpAddress.value,
                port: RCONPort.value,
                password: RCONPassword.value,
                player_steamid: steamid,
            });

            fetch(url, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: data,
            })
                .then((response) => response.json())
                .then((data) => {
                    if (data.status === "success") {
                        // Update the success message format to include player name and SteamID
                        sendOutputMessage(
                            `Player ${
                                action === "kick" ? "Kicked" : "Banned"
                            } - ${playerName} (SteamID: ${steamid})`
                        );
                    } else {
                        // Handle error case
                        sendOutputMessage(data.message);
                    }
                })
                .catch((error) => {
                    console.error("Error:", error);
                });
        }

        // Fix for modal not closing with Bootstrap's close and cancel buttons
        $('.close, .btn-secondary[data-dismiss="modal"]').click(function () {
            $(this).closest(".modal").modal("hide");
        });

        function switchDarkMode() {
            const darkModeState = checkDarkMode.checked ? "dark" : "light";
            // Set the theme for the main document
            document.documentElement.setAttribute(
                "data-bs-theme",
                darkModeState
            );

            // Iterate over all iframes
            if (
                RCONFrame &&
                serverManagerFrame &&
                settingsGenFrame &&
                homeFrame
            ) {
                // Set the theme for each iframe (if available
                RCONFrame.setAttribute("data-bs-theme", darkModeState);
                serverManagerFrame.setAttribute("data-bs-theme", darkModeState);
                settingsGenFrame.setAttribute("data-bs-theme", darkModeState);
                homeFrame.setAttribute("data-bs-theme", darkModeState);
            }
        }

        checkDarkMode.addEventListener("change", () => {
            switchDarkMode();
        });

        // Stuff to run on page load
        let managementMode = "{{ management_mode }}";
        commandOutputContainer.style.bottom = "-200px";
        commandOutputContainer.style.display = "block";
    </script>
</html>
