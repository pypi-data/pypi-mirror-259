/* Autogenerated by mlir-tblgen; don't manually edit */

#ifdef GEN_PASS_DECL
// Generate declarations for all passes.
#define GEN_PASS_DECL_EXPANDFLOATCONVERSIONSPASS
#define GEN_PASS_DECL_LOWERFUNCPASS
#define GEN_PASS_DECL_LOWERTENSORSPASS
#define GEN_PASS_DECL_LOWERTOLLVMPASS
#define GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#define GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#define GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#undef GEN_PASS_DECL
#endif // GEN_PASS_DECL

//===----------------------------------------------------------------------===//
// ExpandFloatConversionsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_EXPANDFLOATCONVERSIONSPASS
struct ExpandFloatConversionsPassOptions {
  bool include_bf16_ = false;
};
std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass();
std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass(const ExpandFloatConversionsPassOptions &options);
#undef GEN_PASS_DECL_EXPANDFLOATCONVERSIONSPASS
#endif // GEN_PASS_DECL_EXPANDFLOATCONVERSIONSPASS
#ifdef GEN_PASS_DEF_EXPANDFLOATCONVERSIONSPASS

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass();
} // namespace impl

namespace impl {
  std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass(const ExpandFloatConversionsPassOptions &options);
} // namespace impl
namespace impl {

template <typename DerivedT>
class ExpandFloatConversionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatConversionsPassBase;

  ExpandFloatConversionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatConversionsPassBase(const ExpandFloatConversionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-expand-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-expand-conversions"; }

  ::llvm::StringRef getDescription() const override { return "Expands float conversions that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatConversionsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatConversionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatConversionsPassBase<DerivedT>)

  ExpandFloatConversionsPassBase(const ExpandFloatConversionsPassOptions &options) : ExpandFloatConversionsPassBase() {
    include_bf16_ = options.include_bf16_;
  }
protected:
  ::mlir::Pass::Option<bool> include_bf16_{*this, "include-bf16", ::llvm::cl::desc("Enable the BF16 <-> F32 expansion patterns."), ::llvm::cl::init(false)};
private:

  friend std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass() {
    return std::make_unique<DerivedT>();
  }

  friend std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass(const ExpandFloatConversionsPassOptions &options) {
    return std::make_unique<DerivedT>(options);
  }
};
} // namespace impl

std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass() {
  return impl::createExpandFloatConversionsPass();
}

std::unique_ptr<::mlir::Pass> createExpandFloatConversionsPass(const ExpandFloatConversionsPassOptions &options) {
  return impl::createExpandFloatConversionsPass(options);
}
#undef GEN_PASS_DEF_EXPANDFLOATCONVERSIONSPASS
#endif // GEN_PASS_DEF_EXPANDFLOATCONVERSIONSPASS

//===----------------------------------------------------------------------===//
// LowerFuncPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERFUNCPASS
#undef GEN_PASS_DECL_LOWERFUNCPASS
#endif // GEN_PASS_DECL_LOWERFUNCPASS
#ifdef GEN_PASS_DEF_LOWERFUNCPASS
namespace impl {

template <typename DerivedT>
class LowerFuncPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerFuncPassBase;

  LowerFuncPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerFuncPassBase(const LowerFuncPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-func");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-func"; }

  ::llvm::StringRef getDescription() const override { return "Lowers function calls to func.calls."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerFuncPass");
  }
  ::llvm::StringRef getName() const override { return "LowerFuncPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerFuncPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERFUNCPASS
#endif // GEN_PASS_DEF_LOWERFUNCPASS

//===----------------------------------------------------------------------===//
// LowerTensorsPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTENSORSPASS
#undef GEN_PASS_DECL_LOWERTENSORSPASS
#endif // GEN_PASS_DECL_LOWERTENSORSPASS
#ifdef GEN_PASS_DEF_LOWERTENSORSPASS
namespace impl {

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERTENSORSPASS
#endif // GEN_PASS_DEF_LOWERTENSORSPASS

//===----------------------------------------------------------------------===//
// LowerToLLVMPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_LOWERTOLLVMPASS
#undef GEN_PASS_DECL_LOWERTOLLVMPASS
#endif // GEN_PASS_DECL_LOWERTOLLVMPASS
#ifdef GEN_PASS_DEF_LOWERTOLLVMPASS
namespace impl {

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_LOWERTOLLVMPASS
#endif // GEN_PASS_DEF_LOWERTOLLVMPASS

//===----------------------------------------------------------------------===//
// MergePointersToSameSlicePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#undef GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#endif // GEN_PASS_DECL_MERGEPOINTERSTOSAMESLICEPASS
#ifdef GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS
namespace impl {

template <typename DerivedT>
class MergePointersToSameSlicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MergePointersToSameSlicePassBase;

  MergePointersToSameSlicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergePointersToSameSlicePassBase(const MergePointersToSameSlicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-merge-pointers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-merge-pointers"; }

  ::llvm::StringRef getDescription() const override { return "Merges pointers that share slices."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergePointersToSameSlicePass");
  }
  ::llvm::StringRef getName() const override { return "MergePointersToSameSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergePointersToSameSlicePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS
#endif // GEN_PASS_DEF_MERGEPOINTERSTOSAMESLICEPASS

//===----------------------------------------------------------------------===//
// PropagateSliceIndicesPass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#undef GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#endif // GEN_PASS_DECL_PROPAGATESLICEINDICESPASS
#ifdef GEN_PASS_DEF_PROPAGATESLICEINDICESPASS
namespace impl {

template <typename DerivedT>
class PropagateSliceIndicesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = PropagateSliceIndicesPassBase;

  PropagateSliceIndicesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateSliceIndicesPassBase(const PropagateSliceIndicesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-propagate-slice-indices");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-propagate-slice-indices"; }

  ::llvm::StringRef getDescription() const override { return "Propagates slice indices from the entry function to all callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateSliceIndicesPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateSliceIndicesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateSliceIndicesPassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_PROPAGATESLICEINDICESPASS
#endif // GEN_PASS_DEF_PROPAGATESLICEINDICESPASS

//===----------------------------------------------------------------------===//
// SimplifyAffinePass
//===----------------------------------------------------------------------===//
#ifdef GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#undef GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#endif // GEN_PASS_DECL_SIMPLIFYAFFINEPASS
#ifdef GEN_PASS_DEF_SIMPLIFYAFFINEPASS
namespace impl {

template <typename DerivedT>
class SimplifyAffinePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyAffinePassBase;

  SimplifyAffinePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyAffinePassBase(const SimplifyAffinePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-affine");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-affine"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies affine.apply using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyAffinePass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Return the dialect that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::affine::AffineDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyAffinePassBase<DerivedT>)

protected:
private:
};
} // namespace impl
#undef GEN_PASS_DEF_SIMPLIFYAFFINEPASS
#endif // GEN_PASS_DEF_SIMPLIFYAFFINEPASS
#ifdef GEN_PASS_REGISTRATION

//===----------------------------------------------------------------------===//
// ExpandFloatConversionsPass Registration
//===----------------------------------------------------------------------===//

inline void registerExpandFloatConversionsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandFloatConversionsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerExpandFloatConversionsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return createExpandFloatConversionsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerFuncPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerFuncPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerFuncPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerFuncPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerFuncPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerTensorsPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerTensorsPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerTensorsPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerTensorsPass();
  });
}

//===----------------------------------------------------------------------===//
// LowerToLLVMPass Registration
//===----------------------------------------------------------------------===//

inline void registerLowerToLLVMPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerToLLVMPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerLowerToLLVMPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateLowerToLLVMPass();
  });
}

//===----------------------------------------------------------------------===//
// MergePointersToSameSlicePass Registration
//===----------------------------------------------------------------------===//

inline void registerMergePointersToSameSlicePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateMergePointersToSameSlicePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerMergePointersToSameSlicePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateMergePointersToSameSlicePass();
  });
}

//===----------------------------------------------------------------------===//
// PropagateSliceIndicesPass Registration
//===----------------------------------------------------------------------===//

inline void registerPropagateSliceIndicesPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePropagateSliceIndicesPass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerPropagateSliceIndicesPassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreatePropagateSliceIndicesPass();
  });
}

//===----------------------------------------------------------------------===//
// SimplifyAffinePass Registration
//===----------------------------------------------------------------------===//

inline void registerSimplifyAffinePass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyAffinePass();
  });
}

// Old registration code, kept for temporary backwards compatibility.
inline void registerSimplifyAffinePassPass() {
  ::mlir::registerPass([]() -> std::unique_ptr<::mlir::Pass> {
    return CreateSimplifyAffinePass();
  });
}

//===----------------------------------------------------------------------===//
// GpuFusionTransforms Registration
//===----------------------------------------------------------------------===//

inline void registerGpuFusionTransformsPasses() {
  registerExpandFloatConversionsPass();
  registerLowerFuncPass();
  registerLowerTensorsPass();
  registerLowerToLLVMPass();
  registerMergePointersToSameSlicePass();
  registerPropagateSliceIndicesPass();
  registerSimplifyAffinePass();
}
#undef GEN_PASS_REGISTRATION
#endif // GEN_PASS_REGISTRATION
// Deprecated. Please use the new per-pass macros.
#ifdef GEN_PASS_CLASSES

template <typename DerivedT>
class ExpandFloatConversionsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = ExpandFloatConversionsPassBase;

  ExpandFloatConversionsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  ExpandFloatConversionsPassBase(const ExpandFloatConversionsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-expand-conversions");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-expand-conversions"; }

  ::llvm::StringRef getDescription() const override { return "Expands float conversions that are not natively supported."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("ExpandFloatConversionsPass");
  }
  ::llvm::StringRef getName() const override { return "ExpandFloatConversionsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::arith::ArithDialect>();
    registry.insert<mlir::mhlo::MhloDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(ExpandFloatConversionsPassBase<DerivedT>)

protected:
  ::mlir::Pass::Option<bool> include_bf16_{*this, "include-bf16", ::llvm::cl::desc("Enable the BF16 <-> F32 expansion patterns."), ::llvm::cl::init(false)};
};

template <typename DerivedT>
class LowerFuncPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerFuncPassBase;

  LowerFuncPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerFuncPassBase(const LowerFuncPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-func");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-func"; }

  ::llvm::StringRef getDescription() const override { return "Lowers function calls to func.calls."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerFuncPass");
  }
  ::llvm::StringRef getName() const override { return "LowerFuncPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<xla::gpu::XlaGpuDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerFuncPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerTensorsPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerTensorsPassBase;

  LowerTensorsPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerTensorsPassBase(const LowerTensorsPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-tensors");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-tensors"; }

  ::llvm::StringRef getDescription() const override { return "Lowers tensors to llvm pointers and loads/stores."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerTensorsPass");
  }
  ::llvm::StringRef getName() const override { return "LowerTensorsPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::gpu::GPUDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
    registry.insert<mlir::tensor::TensorDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerTensorsPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class LowerToLLVMPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = LowerToLLVMPassBase;

  LowerToLLVMPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  LowerToLLVMPassBase(const LowerToLLVMPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-lower-to-llvm");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-lower-to-llvm"; }

  ::llvm::StringRef getDescription() const override { return "Lowers to LLVM."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("LowerToLLVMPass");
  }
  ::llvm::StringRef getName() const override { return "LowerToLLVMPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::LLVM::LLVMDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(LowerToLLVMPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class MergePointersToSameSlicePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = MergePointersToSameSlicePassBase;

  MergePointersToSameSlicePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  MergePointersToSameSlicePassBase(const MergePointersToSameSlicePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-merge-pointers");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-merge-pointers"; }

  ::llvm::StringRef getDescription() const override { return "Merges pointers that share slices."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("MergePointersToSameSlicePass");
  }
  ::llvm::StringRef getName() const override { return "MergePointersToSameSlicePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(MergePointersToSameSlicePassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class PropagateSliceIndicesPassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = PropagateSliceIndicesPassBase;

  PropagateSliceIndicesPassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  PropagateSliceIndicesPassBase(const PropagateSliceIndicesPassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-propagate-slice-indices");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-propagate-slice-indices"; }

  ::llvm::StringRef getDescription() const override { return "Propagates slice indices from the entry function to all callees."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("PropagateSliceIndicesPass");
  }
  ::llvm::StringRef getName() const override { return "PropagateSliceIndicesPass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::func::FuncDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(PropagateSliceIndicesPassBase<DerivedT>)

protected:
};

template <typename DerivedT>
class SimplifyAffinePassBase : public ::mlir::OperationPass<mlir::ModuleOp> {
public:
  using Base = SimplifyAffinePassBase;

  SimplifyAffinePassBase() : ::mlir::OperationPass<mlir::ModuleOp>(::mlir::TypeID::get<DerivedT>()) {}
  SimplifyAffinePassBase(const SimplifyAffinePassBase &other) : ::mlir::OperationPass<mlir::ModuleOp>(other) {}

  /// Returns the command-line argument attached to this pass.
  static constexpr ::llvm::StringLiteral getArgumentName() {
    return ::llvm::StringLiteral("xla-gpu-simplify-affine");
  }
  ::llvm::StringRef getArgument() const override { return "xla-gpu-simplify-affine"; }

  ::llvm::StringRef getDescription() const override { return "Simplifies affine.apply using XLA's range-aware simplifier."; }

  /// Returns the derived pass name.
  static constexpr ::llvm::StringLiteral getPassName() {
    return ::llvm::StringLiteral("SimplifyAffinePass");
  }
  ::llvm::StringRef getName() const override { return "SimplifyAffinePass"; }

  /// Support isa/dyn_cast functionality for the derived pass class.
  static bool classof(const ::mlir::Pass *pass) {
    return pass->getTypeID() == ::mlir::TypeID::get<DerivedT>();
  }

  /// A clone method to create a copy of this pass.
  std::unique_ptr<::mlir::Pass> clonePass() const override {
    return std::make_unique<DerivedT>(*static_cast<const DerivedT *>(this));
  }

  /// Register the dialects that must be loaded in the context before this pass.
  void getDependentDialects(::mlir::DialectRegistry &registry) const override {
    registry.insert<mlir::affine::AffineDialect>();
    registry.insert<mlir::func::FuncDialect>();
    registry.insert<mlir::scf::SCFDialect>();
  }

  /// Explicitly declare the TypeID for this class. We declare an explicit private
  /// instantiation because Pass classes should only be visible by the current
  /// library.
  MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID(SimplifyAffinePassBase<DerivedT>)

protected:
};
#undef GEN_PASS_CLASSES
#endif // GEN_PASS_CLASSES
