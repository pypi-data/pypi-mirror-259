"""The Documents Call Model module.

This module contains an API for /v1/documents call body.
It exports the following classes:

    * DocumentsBodyPart
        A class representing /v1/documents body part.
    * DocumentsContentDisposition
        A class representing /v1/documents body part Content-Disposition header.
    * DocumentsBodyPartType
        An enumeration class representing /v1/documents body part types.
    * Repair
        An enumeration class representing repair levels.
    * Extract
        An enumeration class representing metadata extract types.
    * Category
        An enumeration class representing data categories.
    * ContentDispositionSerializer
        A Content-Disposition header serializer.
"""
from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union

from pydantic import BaseModel, Field, field_validator

from mlclient.constants import HEADER_JSON
from mlclient.model import DocumentType
from mlclient.utils import BiDict


class DocumentsBodyPartType(Enum):
    """An enumeration class representing /v1/documents body part types."""

    INLINE = "inline"
    ATTACHMENT = "attachment"


class Repair(Enum):
    """An enumeration class representing repair levels."""

    NONE = "none"
    FULL = "full"


class Extract(Enum):
    """An enumeration class representing metadata extract types."""

    PROPERTIES = "properties"
    DOCUMENT = "document"


class Category(Enum):
    """An enumeration class representing data categories."""

    CONTENT = "content"
    METADATA = "metadata"
    METADATA_VALUES = "metadata-values"
    COLLECTIONS = "collections"
    PERMISSIONS = "permissions"
    PROPERTIES = "properties"
    QUALITY = "quality"


class DocumentsContentDisposition(BaseModel):
    """A class representing /v1/documents body part Content-Disposition header."""

    body_part_type: DocumentsBodyPartType = Field(
        description="The content type indication (inline or attachment).",
    )
    category: Optional[Union[Category, List[Category]]] = Field(
        description="The category of data.",
        default=None,
    )
    repair: Optional[Repair] = Field(
        description="For an XML content part, the level of XML repair to perform. "
        "Allowed values: full (default) or none. "
        "Use full to request the server to repair malformed input XML. "
        "Use none to request the server to reject malformed input XML. "
        "If repair results in multiple root nodes, the update is rejected.",
        default=None,
    )
    filename: Optional[str] = Field(
        description="Specifies an explicit document URI. "
        "Use extension to have MarkLogic Server generate a URI instead. "
        "For a given part, filename and extension are mutually exclusive.",
        default=None,
    )
    extension: Optional[str] = Field(
        description="Specifies a URI extension to use when the document URI "
        "is generated by MarkLogic Server. "
        "The generated URI will end with '.' plus this extension. "
        "For a given part, filename and extension are mutually exclusive.",
        default=None,
    )
    directory: Optional[str] = Field(
        description="Specifies a directory prefix to use when the document URI "
        "is generated by MarkLogic Server. "
        "The directory prefix must end with '/'. "
        "If the part header includes a directory parameter, "
        "it must also include an extension parameter. "
        "For a given part, filename and directory are mutually exclusive.",
        default=None,
    )
    extract: Optional[Extract] = Field(
        description="For a binary content part, whether or not to extract metadata, "
        "and whether to store the extracted metadata as document properties"
        "or in a separate XHTML document. "
        "Allowed values: properties or document.",
        default=None,
    )
    version_id: Optional[int] = Field(
        description="When optimistic locking is enabled by setting the REST instance "
        "configuration property update-policy to version-required or "
        "version-optional, reject this request if the current version "
        "of this document does not match the version in versionId. "
        "Only applicable to content parts. "
        "Ignored if optimistic locking is not enabled. "
        "This option is equivalent to supplying a version id "
        "through the If-Match header of a single document update.",
        default=None,
    )
    temporal_document: Optional[str] = Field(
        description="The 'logical' document URI in the temporal collection specified "
        "using the temporal-collection request parameter. "
        "You can only use this parameter if the request also includes "
        "the temporal-collection parameter.",
        default=None,
    )
    format_: Optional[DocumentType] = Field(
        description="The content format (xml, json, text or binary)",
        alias="format",
        default=None,
    )


class DocumentsBodyPart(BaseModel):
    """A class representing /v1/documents body part."""

    content_type: str = Field(alias="content-type", default=HEADER_JSON)
    content_disposition: DocumentsContentDisposition = Field(
        alias="content-disposition",
    )
    content: Union[str, bytes, dict]

    @field_validator("content_disposition", mode="before")
    @classmethod
    def parse_content_disposition(
        cls,
        value: str | dict,
    ) -> DocumentsContentDisposition:
        """Parse a Content-Disposition header."""
        if isinstance(value, dict):
            return DocumentsContentDisposition(**value)
        return ContentDispositionSerializer.serialize(value)


class ContentDispositionSerializer:
    """A Content-Disposition header serializer."""

    _DISP_SEP = "; "
    _KEY_VALUE_SEP = "="
    _CLASS_KEY_BODY_PART_TYPE = "body_part_type"
    _CLASS_KEY_CATEGORY = "category"
    _CLASS_KEY_REPAIR = "repair"
    _CLASS_KEY_FILENAME = "filename"
    _CLASS_KEY_EXTENSION = "extension"
    _CLASS_KEY_DIRECTORY = "directory"
    _CLASS_KEY_EXTRACT = "extract"
    _CLASS_KEY_VERSION_ID = "version_id"
    _CLASS_KEY_TEMPORAL_DOC = "temporal_document"
    _CLASS_KEY_FORMAT = "format_"
    _CLASS_KEY_FORMAT_ALIAS = "format"
    _DISP_KEY_BODY_PART_TYPE = None
    _DISP_KEY_CATEGORY = _CLASS_KEY_CATEGORY
    _DISP_KEY_REPAIR = _CLASS_KEY_REPAIR
    _DISP_KEY_FILENAME = _CLASS_KEY_FILENAME
    _DISP_KEY_EXTENSION = _CLASS_KEY_EXTENSION
    _DISP_KEY_DIRECTORY = _CLASS_KEY_DIRECTORY
    _DISP_KEY_EXTRACT = _CLASS_KEY_EXTRACT
    _DISP_KEY_VERSION_ID = "versionId"
    _DISP_KEY_TEMPORAL_DOC = "temporal-document"
    _DISP_KEY_FORMAT = _CLASS_KEY_FORMAT_ALIAS
    _DISPOSITIONS = BiDict(
        {
            _CLASS_KEY_BODY_PART_TYPE: _DISP_KEY_BODY_PART_TYPE,
            _CLASS_KEY_CATEGORY: _DISP_KEY_CATEGORY,
            _CLASS_KEY_REPAIR: _DISP_KEY_REPAIR,
            _CLASS_KEY_FILENAME: _DISP_KEY_FILENAME,
            _CLASS_KEY_EXTENSION: _DISP_KEY_EXTENSION,
            _CLASS_KEY_DIRECTORY: _DISP_KEY_DIRECTORY,
            _CLASS_KEY_EXTRACT: _DISP_KEY_EXTRACT,
            _CLASS_KEY_VERSION_ID: _DISP_KEY_VERSION_ID,
            _CLASS_KEY_TEMPORAL_DOC: _DISP_KEY_TEMPORAL_DOC,
            _CLASS_KEY_FORMAT: _DISP_KEY_FORMAT,
        },
    )

    @classmethod
    def serialize(
        cls,
        content_disposition: str,
    ) -> DocumentsContentDisposition:
        """Serialize a raw Content-Disposition header.

        Creates and initializes a DocumentsContentDisposition instance.

        Parameters
        ----------
        content_disposition : str
            A raw Content-Disposition header value

        Returns
        -------
        DocumentsContentDisposition
            A serialized DocumentsContentDisposition instance
        """
        disp_dict = {}
        for disp in content_disposition.split(cls._DISP_SEP):
            key, value = cls._get_disp_key_and_value(disp)
            curr_value = disp_dict.get(key)
            if curr_value is None:
                disp_dict[key] = value
            elif not isinstance(curr_value, list):
                disp_dict[key] = [curr_value, value]
            else:
                curr_value.append(value)
        return DocumentsContentDisposition(**disp_dict)

    @classmethod
    def _get_disp_key_and_value(
        cls,
        disp: str,
    ) -> tuple[str, str]:
        """Return a single DocumentsContentDisposition-like disposition key and value.

        Parameters
        ----------
        disp : str
            A single disposition

        Returns
        -------
        tuple[str, str]
            A single DocumentsContentDisposition-like disposition key and value
        """
        key_value_pair = disp.split(cls._KEY_VALUE_SEP)
        if len(key_value_pair) == 1:
            key = None
            value = key_value_pair[0]
        else:
            key, value = key_value_pair
        return cls._parse_disp_key_and_value(key, value)

    @classmethod
    def _parse_disp_key_and_value(
        cls,
        key: str,
        value: str,
    ) -> tuple[str, str]:
        """Parse a single raw Content-Disposition key and value.

        Parameters
        ----------
        key : str
            A single disposition key
        value : str
            A single disposition value

        Returns
        -------
        tuple[str, str]
            A single DocumentsContentDisposition-like disposition key and value
        """
        key = cls._DISPOSITIONS.get(key)
        if key == cls._CLASS_KEY_FORMAT:
            key = cls._CLASS_KEY_FORMAT_ALIAS
        value = value[1:-1] if key == cls._DISP_KEY_FILENAME else value
        return key, value

    @classmethod
    def deserialize(
        cls,
        content_disposition: DocumentsContentDisposition,
    ) -> str:
        """Deserialize a DocumentsContentDisposition instance.

        Parses a DocumentsContentDisposition instance to a string representation

        Parameters
        ----------
        content_disposition : DocumentsContentDisposition
            A DocumentsContentDisposition instance

        Returns
        -------
        str
            A raw Content-Disposition header value
        """
        disposition = [
            cls._get_disposition(content_disposition, cls._CLASS_KEY_BODY_PART_TYPE),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_FILENAME),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_CATEGORY),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_EXTENSION),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_DIRECTORY),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_REPAIR),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_EXTRACT),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_VERSION_ID),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_TEMPORAL_DOC),
            cls._get_disposition(content_disposition, cls._CLASS_KEY_FORMAT),
        ]

        return cls._DISP_SEP.join([disp for disp in disposition if disp is not None])

    @classmethod
    def _get_disposition(
        cls,
        content_disposition: DocumentsContentDisposition,
        class_key: str,
    ) -> str | None:
        """Parse a single DocumentsContentDisposition attribute to a string.

        Parameters
        ----------
        content_disposition : DocumentsContentDisposition
            A DocumentsContentDisposition instance
        class_key : str
            A DocumentsContentDisposition class attribute key

        Returns
        -------
        str | None
            A single raw disposition key-value pair
        """
        disp_value = content_disposition.model_dump().get(class_key)
        if disp_value is None:
            return None
        disp = cls._DISPOSITIONS.get(class_key)

        if not isinstance(disp_value, list):
            disp_value = [disp_value]

        dispositions = []
        for value in disp_value:
            if isinstance(value, Enum):
                final_value = value.value
            elif disp == cls._DISP_KEY_FILENAME:
                final_value = f'"{value}"'
            else:
                final_value = value
            disposition = final_value if disp is None else f"{disp}={final_value}"
            dispositions.append(disposition)
        return "; ".join(dispositions)
