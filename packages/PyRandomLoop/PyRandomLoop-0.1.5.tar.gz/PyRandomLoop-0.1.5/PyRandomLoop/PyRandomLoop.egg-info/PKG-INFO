Metadata-Version: 2.1
Name: PyRandomLoop
Version: 0.1.5
Summary: Provides a simulation framework for a random loop model in statistical mechanics, including initialization, simulation, and visualization capabilities.
Author: Lorenzo Gregoris
Author-email: lorenzo.gregoris@gmail.com
License: MIT
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.9
Description-Content-Type: text/markdown
License-File: LICENSE.txt

PyRandomLoop is a Python package designed for simulating and visualizing a random loop model on a 2d grid. 
The core of the simulation is the class `StateSpace`. It provides methods for initializing the grid, running the simulation, visualization, saving and loading the state of the simulation, and calculating various statistics.

## Features

- Initialize the grid with a specified number of colors, grid size, and boundary conditions.
- Run the simulation using the Metropolis or Glauber algorithm.
- Save and load the state of the simulation to/from a file.
- Calculate and visualize various statistics about the loops formed by each color.

## Examples

### Initializing the Grid and Running the Simulation

To initiate the grid and run the simulation, you can use the following code:
```python
from PyRandomLoop import StateSpace

# Initialize the grid with 3 colors, a grid size of 64 by 64, and a beta value of 1.7
sim = StateSpace(num_colors=3, grid_size=64, beta=1.7)

# Run the simulation for 1000 steps, showing a progress bar
sim.step(10_000, progress_bar=True)

# Save the state of the simulation to a file
sim.save_state('example.json')

# Load the state of the simulation from a file later
sim.load_state('example.json')
```
### Visualizing the Grid Using the Plot Functions
To visualize the grid using the plot functions, you can use the following code:

```python
# Plot the grid for all colors
sim.plot_grid()

# Plot the overlap of all colors in the grid
sim.plot_overlap()
```

### Creating an Animation Using the Animate Method
To create an animation using the animate method first you need to sample the grid during the simulation:

```python
# sample grid state every 1000 steps
sim.step(100_000, sample_rate=1_000, progress_bar=True)

# Create an animation using the animate method
animation = sim.animate(frames=100)

# Save the animation
animation.save('example.gif')
```

### Studying Observables During the Simulation
To study observables during the simulation, you can define a list or a dictionary of callable objects, which will be called every sample_rate:

```python
# Define custom observables using built-in methods or custom functions

def custom_obs():
    return np.log( sim.avg_local_time() )

observables = {
    'avg_links': sim.avg_links,
    'max_links': sim.max_links,
    'avg_local_time': sim.avg_local_time,
    'custom_obs': custom_obs,
    'links_std': lambda : np.std(m.grid, axis = (1,2,3))
}

# Create a loop builder to study observables during the simulation
loop_builder = grid.loop_builder(num_steps=100_000, sample_rate=1_000, observables=observables)

# Analyze the collected data
print(sim.data)
```

### Study loops
After running the simulation, we can calculate the loops and their length for each color using the loop_builder method.

```python
import matplotlib.pyplot as plt

# Initialize the grid with 3 colors, a grid size of 100, and a beta value of 1.5
sim = StateSpace(3, 64, 5)

# Run the simulation
sim.step(100_000)

# Calculate the loops for each color
loops, lengths = sim.loop_builder()

# Plot the histogram of loop lengths for each color
for c in range(sim.num_colors):
    plt.hist(lengths[c], log = True, align='left', label='Color {}'.format(c))

plt.xlabel('Loop Length')
plt.ylabel('Frequency')
plt.legend()
plt.show()

# plot 3 longest loops of color 0
# find top 10 longest loops
# print top 10
sorted = np.sort(lengths[0])[-3:]

top_three =  []

for l in loops[0]:
    if len(l) in sorted:
        top.append(l)

#plot it 
m.plot_loop(0, top_three, alpha = 0.5) #, colors=colors)
```
