# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['T', 'P', 'VArgs', 'Tuples', 'isnone', 'isbool', 'getname', 'private', 'mangled', 'unmangle', 'parameter_defaults',
           'DictMethod', 'Keyword', 'extract_keyword', 'update_keyword', 'overload_keyword', 'overload', 'okw']

# %% ../nbs/00_core.ipynb 6
from enum import StrEnum, auto
from inspect import getargvalues, currentframe, signature, Signature, Parameter
from functools import wraps, partial

# %% ../nbs/00_core.ipynb 8
from typing import (Any, Self, Type, Union, Callable, TypeVar, TypeAlias, TypeGuard, ParamSpec, NamedTuple, overload)

# %% ../nbs/00_core.ipynb 10
#| export


# %% ../nbs/00_core.ipynb 12
#| export


# %% ../nbs/00_core.ipynb 14
#| export


# %% ../nbs/00_core.ipynb 16
#| export


# %% ../nbs/00_core.ipynb 18
T = TypeVar('T')

P = ParamSpec('P')

VArgs: TypeAlias = tuple[T, ...]
'''Variadic arguments, i.e. `*args`.''';

Tuples: TypeAlias = tuple[tuple, ...]
'''Tuple of tuples.''';

# %% ../nbs/00_core.ipynb 20
def isnone(x) -> TypeGuard[None]:
    '''Check if `x` is `None`'''
    return x is None

def isbool(x) -> TypeGuard[bool]:
    '''Check if `x` is a `bool`'''
    return isinstance(x, bool)

# %% ../nbs/00_core.ipynb 22
U1 = '_'
U2 = '__'

GET = 'get'
POP = 'pop'


DEFAULT = 'default'

__DOC__ = '__doc__'
__NAME__ = '__name__'
__QUALNAME__ = '__qualname__'
__ANNOTATIONS__ = '__annotations__'

# %% ../nbs/00_core.ipynb 24
def getname(obj: object) -> str:
    '''Return the name, qualname, or string representaiton of an object.'''
    return getattr(obj, __NAME__, getattr(obj, __QUALNAME__, str(obj)))

def private(attr: str) -> str:
    '''Return the private version of an attribute name i.e. `f'_{attr}'`.'''
    return f'{U1}{attr.lstrip(U1)}'

def mangled(cls: object, attr: str) -> str:
    '''Return the mangled version of a class's attribute i.e. `f'_{clsname}__{attr}'`.'''
    return f'{private(getname(cls))}{U2}{attr.lstrip(U2)}'

def unmangle(cls: object, attr: str) -> str:
    '''Return the unmangled version of a class's attribute i.e. `f'{attr}'`.'''
    return attr.split(private(getname(cls)))[-1]

# %% ../nbs/00_core.ipynb 26
def parameter_defaults(fn: Callable) -> dict:
    '''Return a dictionary of parameter defaults if they exist.'''
    sig = signature(fn)
    return dict(((k, v.default) for k, v in sig.parameters.items() if v.default is not Parameter.empty))

# %% ../nbs/00_core.ipynb 28
class DictMethod(StrEnum):
    GET = auto()
    POP = auto()
    DEFAULT = POP
    
    @classmethod
    def safe(
        cls: Type['DictMethod'], 
        member: Union['DictMethod', str, bool, None] = None
    ) -> 'DictMethod':
        '''Retrieve a safe enum member based on the given value. If the member is not a valid member,
        the default member is returned instead.

        Parameters
        ----------
        member : DictMethod | str | bool | None, optional
            The member to retrieve. Can be an enum member or its name as a string. Default is None.

        Returns
        -------
        DictMethod
            The retrieved enum member.
        '''
        if isbool(member): return cls.POP if member else cls.GET
        return member if member in cls.__members__.values() else cls.DEFAULT

    @classmethod
    def get(
        cls: Type['DictMethod'], 
        __dict: dict | None = None, 
        __dict_method: Union['DictMethod', str, bool, None] = DEFAULT
    ) -> Callable[[str, Any], Any]:
        '''Get the method to use based on the given dictionary `__dict` 
        and method `__dict_method`.
        
        Parameters
        ----------        
        __dict : dict | None, optional
            The dictionary to operate on. Default is None.
            
        __dict_method : DictMethod | str | bool | None, default: 'default'
            The method to use. Note that `'default'` results in `pop` being used.
            
        Returns
        -------
        Callable[[str, Any], Any]
            The method to use. `__dict.get` or `__dict.pop`.
        '''
        method = cls.safe(__dict_method)
        # print('make', method, __dict_method)
        __dict = __dict or {}
        match method: 
            case cls.GET:
                return __dict.get
            case cls.POP:
                return __dict.pop
            case _:
                return __dict.get
            
    @classmethod
    def make(
        cls: Type['DictMethod'], 
        __dict: dict | None = None, 
        __dict_method: Union['DictMethod', str, bool, None] = DEFAULT
    ) -> Callable[[str, Any], Any]:
        '''Make the wrapped extractor function based on the given dictionary `__dict` 
        and method `__dict_method`.
        
        Parameters
        ----------
        __dict : dict | None, optional
            The dictionary to operate on. Default is None.
            
        __dict_method : DictMethod | str | bool | None, default: 'default'
            The method to use. Note that `'default'` results in `pop` being used.
            
        Returns
        -------
        `(kw: str, default: Any) -> Any`
            The wrapped getter function to use.
        '''
        # print('make', __dict_method)
        
        method = cls.get(__dict, __dict_method)
        @wraps(method, assigned=(__DOC__, __NAME__, __QUALNAME__))
        def extract(kw: str, default: Any = None) -> Any:
            return method(kw, default)
        return extract

# %% ../nbs/00_core.ipynb 30
class Keyword(NamedTuple):
    '''A named tuple representing a specification.'''
    keyword: str
    '''The keyword to extract from `kwargs`.''';
    
    options: tuple[str, ...] = ()
    '''Synonyms for `keyword` to extract from `kwargs` if `keyword` not found.''';
    
    default: Any = None
    '''The default value to return if no value is found in `kwargs`.''';
    
    newname: str | None = None
    '''The new name to store the value in `kwargs`.'''
    
    @property
    def opts(self) -> tuple[str, ...]:
        '''Return the keyword and options as a tuple.'''
        return list((self.keyword, *self.options))
    
    @property
    def name(self) -> str:
        '''Return the name of th keyword to store in `kwargs`.'''
        return self.newname or self.keyword
    
    def remove(self: Self, **kwargs) -> dict:
        '''Remove the keyword and options from `kwargs` via `kwargs.pop`.'''
        for opt in set((self.opts)): 
            kwargs.pop(opt, None)
        return kwargs
    
    @overload
    def extract(self: Self, __dict_method: DictMethod | str | bool | None = DictMethod.DEFAULT, **kwargs) -> Any: ...
    @overload
    def extract(self: Self, __dict_method: DictMethod = DictMethod.DEFAULT, **kwargs) -> Any: ...
    @overload
    def extract(self: Self, **kwargs) -> Any: ...
    def extract(self: Self, __dict_method: DictMethod | str | bool | None = DictMethod.DEFAULT, **kwargs) -> Any:
        '''extract the first non-None value of the `keyword` (or `options`) from `kwargs` using 
        the given method `__method`.
        
        Parameters
        ----------
        __dict_method : DictMethod | str | bool | None, default: DictMethod.DEFAULT
            The method to use. Note that `'default'` results in `pop` being used.
            
        Returns
        -------
        result : Any
            The extracted value.
            
        Notes
        -----
        If `__dict_method` is `'pop'`, the keyword and options are removed from `kwargs`.
        '''
        # print(__dict_method, kwargs)
        # print('extract', __dict_method)
        __dict_method = kwargs.pop('__dict_method', __dict_method) 
        result, values = self.default, []
        getter = DictMethod.get(kwargs, __dict_method)
        
        for opt in self.opts:
            if opt not in kwargs: continue
            result = getter(opt, result)
            values.append(result)
            if result: break
        
        result = next((val for val in values if val), self.default)
        if __dict_method == DictMethod.POP:
            kwargs = self.remove(**kwargs)
                
        return result
        
    @overload
    def update(self: Self, __dict_method: DictMethod | str | bool | None = DictMethod.DEFAULT, **kwargs) -> Any: ...
    @overload
    def update(self: Self, __dict_method: DictMethod = DictMethod.DEFAULT, **kwargs) -> Any: ...
    @overload
    def update(self: Self, **kwargs) -> Any: ...
    def update(self: Self, __dict_method: DictMethod | str | bool | None = DictMethod.DEFAULT, **kwargs) -> dict:
        '''extract the first non-None value of the `keyword` (or `options`) from `kwargs` using 
        the given method `__method`.
        
        Parameters
        ----------
        __dict_method : DictMethod | str | bool | None, default: DictMethod.DEFAULT
            The method to use. Note that `'default'` results in `pop` being used.
            
        Returns
        -------
        dict
            The updated `kwargs` with the extracted value stored under `self.name`.
            
        Notes
        -----
        If `__dict_method` is `'pop'`, the keyword and options are removed from `kwargs`.
        '''
        # print(__dict_method, kwargs)
        __dict_method = kwargs.pop('__dict_method', __dict_method) 
        # print('update', __dict_method)
        result = self.extract(__dict_method=__dict_method, **kwargs)
        if __dict_method == DictMethod.POP:
            kwargs = self.remove(**kwargs)
        kwargs[self.name] = result
        return kwargs

# %% ../nbs/00_core.ipynb 34
@wraps(Keyword.extract, assigned=(__DOC__, __NAME__, __QUALNAME__))
@overload
def extract_keyword(
    keyword: str, options: tuple[str, ...] = (), default: Any = None, 
    __newkw: str | None = None, __dfunc: DictMethod = DictMethod.DEFAULT, **kwargs
) -> Any: ...
@overload
def extract_keyword(keyword: str, options: tuple[str, ...] = (), default: Any = None, **kwargs) -> Any: ...
def extract_keyword(
    keyword: str, 
    options: tuple[str, ...] = (), 
    default: Any = None, 
    __newkw: str | None = None,
    __dfunc: DictMethod = DictMethod.DEFAULT,
    **kwargs
) -> Any:
    __dict_method = kwargs.pop('__dict_method', kwargs.pop('__dfunc', __dfunc))
    kw = Keyword(keyword, options, default, __newkw)
    return kw.extract(__dict_method=__dict_method, **kwargs)

# %% ../nbs/00_core.ipynb 39
@wraps(Keyword.update, assigned=(__DOC__, __NAME__, __QUALNAME__))
@overload
def update_keyword(
    keyword: str,  options: tuple[str, ...] = (), default: Any = None, 
    __newkw: str | None = None, __dfunc: DictMethod = DictMethod.DEFAULT, **kwargs
) -> Any: ...
@overload
def update_keyword(keyword: str,  options: tuple[str, ...] = (), default: Any = None,  **kwargs) -> Any: ...
def update_keyword(
    keyword: str, 
    options: tuple[str, ...] = (), 
    default: Any = None, 
    __newkw: str | None = None,
    __dfunc: DictMethod = DictMethod.DEFAULT,
    **kwargs
) -> Any:
    __dict_method = kwargs.pop('__dict_method', kwargs.pop('__dfunc', __dfunc))
    kw = Keyword(keyword, options, default, __newkw)
    return kw.update(__dict_method=__dict_method, **kwargs)

# %% ../nbs/00_core.ipynb 43
@overload
def overload_keyword(
    keyword: str, options: tuple[str, ...] = (), default: Any = None, 
    __newkw: str | None= None, __dfunc: DictMethod = DictMethod.DEFAULT
) -> Callable[[Callable], Callable[P, Any]]: ...
@overload
def overload_keyword(
    keyword: str, options: tuple[str, ...] = (), default: Any = None, 
    __newkw: str | None = None, __dfunc: DictMethod = DictMethod.DEFAULT,  **kwargs
) -> Callable[[Callable], Callable[P, Any]]: ...
@overload
def overload_keyword(
    keyword: str, options: tuple[str, ...] = (), default: Any = None, **kwargs
) -> Callable[[Callable], Callable[P, Any]]: ...
def overload_keyword(
    keyword: str, 
    options: tuple[str, ...] = (), 
    default: Any = None, 
    __newkw: str | None= None,
    __dfunc: DictMethod = DictMethod.DEFAULT
) -> Callable[[Callable], Callable[P, Any]]:
    '''A decorator to overload a keyword argument for a function.

    Parameters
    ----------
    keyword : str
        The primary keyword to check in the function's keyword arguments.
    
    options : Tuple[str, ...], optional
        Other keyword arguments to check in order of preference.
    
    default : Any, optional
        The default value to use if none of the keywords are present.
    
    __newkw : str | None, optional
        The new keyword to use in place of the old one. Default is None.
        
    __dfunc : DictMethod, default: DictMethod.pop
        Whether to just `get` the keyword from the wrapped `**kwargs` or
        remove (i.e. `pop`) the old keywords from the keyword arguments. 


    Returns
    -------
    Callable
        A decorator that wraps the function and overloads the specified keyword argument.
    '''
    def decorator(fn: Callable) -> Callable[P, Any]:
        @wraps(fn)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -> Any:
            defaults = parameter_defaults(fn)
            for k, v in defaults.items():
                kwargs.setdefault(k, v)
            keywords = update_keyword(keyword, options, default, __newkw, __dfunc, **kwargs)
            return fn(*args, **keywords)
        return wrapper
    return decorator

# %% ../nbs/00_core.ipynb 45
@wraps(overload_keyword, assigned=(__DOC__, __NAME__, __QUALNAME__, __ANNOTATIONS__))
def overload(*args, **kwargs):
    return overload_keyword(*args, **kwargs)

@wraps(overload_keyword, assigned=(__DOC__, __NAME__, __QUALNAME__, __ANNOTATIONS__))
def okw(*args, **kwargs):
    return overload_keyword(*args, **kwargs)
