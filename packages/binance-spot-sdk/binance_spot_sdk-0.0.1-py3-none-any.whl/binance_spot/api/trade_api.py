# coding: utf-8

"""
    Binance Public Spot API

    OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)  # noqa: E501

    OpenAPI spec version: 1.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from binance_spot.api_client import ApiClient


class TradeApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def api_v3_account_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Account Information (USER_DATA)  # noqa: E501

        Get current account information.  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_account_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_account_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_account_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_account_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Account Information (USER_DATA)  # noqa: E501

        Get current account information.  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_account_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_account_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_account_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_account_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/account', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_all_order_list_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query all OCO (USER_DATA)  # noqa: E501

        Retrieves all OCO based on provided optional parameters  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_all_order_list_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int from_id: Trade id to fetch from. Default gets most recent trades.
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20012]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_all_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_all_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_all_order_list_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query all OCO (USER_DATA)  # noqa: E501

        Retrieves all OCO based on provided optional parameters  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_all_order_list_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int from_id: Trade id to fetch from. Default gets most recent trades.
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20012]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'from_id', 'start_time', 'end_time', 'limit', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_all_order_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_all_order_list_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_all_order_list_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('startTime', params['start_time']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/allOrderList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20012]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_all_orders_get(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """All Orders (USER_DATA)  # noqa: E501

        Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_all_orders_get(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[OrderDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_all_orders_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_all_orders_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_all_orders_get_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """All Orders (USER_DATA)  # noqa: E501

        Get all account orders; active, canceled, or filled..  - If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time. - If `startTime` and/or `endTime` provided, `orderId` is not required  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_all_orders_get_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[OrderDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'order_id', 'start_time', 'end_time', 'limit', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_all_orders_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_all_orders_get`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_all_orders_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_all_orders_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('startTime', params['start_time']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/allOrders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OrderDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_my_allocations_get(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Allocations (USER_DATA)  # noqa: E501

        Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_allocations_get(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int from_allocation_id:
        :param int limit: Default 500; max 1000.
        :param int order_id: Order id
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20017]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_my_allocations_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_my_allocations_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_my_allocations_get_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Allocations (USER_DATA)  # noqa: E501

        Retrieves allocations resulting from SOR order placement.  Weight: 20  Supported parameter combinations: Parameters                            Response symbol                                allocations from oldest to newest symbol + startTime                    oldest allocations since startTime symbol + endTime                      newest allocations until endTime symbol + startTime + endTime          allocations within the time range symbol + fromAllocationId            allocations by allocation ID symbol + orderId                      allocations related to an order starting with oldest symbol + orderId + fromAllocationId  allocations related to an order by allocation ID  Note: The time between startTime and endTime can't be longer than 24 hours.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_allocations_get_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int from_allocation_id:
        :param int limit: Default 500; max 1000.
        :param int order_id: Order id
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20017]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'start_time', 'end_time', 'from_allocation_id', 'limit', 'order_id', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_my_allocations_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_my_allocations_get`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_my_allocations_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_my_allocations_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('startTime', params['start_time']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))  # noqa: E501
        if 'from_allocation_id' in params:
            query_params.append(('fromAllocationId', params['from_allocation_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/myAllocations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20017]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_my_prevented_matches_get(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Prevented Matches  # noqa: E501

        Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_prevented_matches_get(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int prevented_match_id:
        :param int order_id: Order id
        :param int from_prevented_match_id:
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20016]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_my_prevented_matches_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_my_prevented_matches_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_my_prevented_matches_get_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Prevented Matches  # noqa: E501

        Displays the list of orders that were expired because of STP.  For additional information on what a Prevented match is, as well as Self Trade Prevention (STP), please refer to our STP FAQ page.  These are the combinations supported:  * symbol + preventedMatchId * symbol + orderId * symbol + orderId + fromPreventedMatchId (limit will default to 500) * symbol + orderId + fromPreventedMatchId + limit  Weight(IP):  Case                            Weight If symbol is invalid:          2 Querying by preventedMatchId:  2 Querying by orderId:            20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_prevented_matches_get_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int prevented_match_id:
        :param int order_id: Order id
        :param int from_prevented_match_id:
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20016]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'prevented_match_id', 'order_id', 'from_prevented_match_id', 'limit', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_my_prevented_matches_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_my_prevented_matches_get`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_my_prevented_matches_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_my_prevented_matches_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'prevented_match_id' in params:
            query_params.append(('preventedMatchId', params['prevented_match_id']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'from_prevented_match_id' in params:
            query_params.append(('fromPreventedMatchId', params['from_prevented_match_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/myPreventedMatches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20016]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_my_trades_get(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Account Trade List (USER_DATA)  # noqa: E501

        Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_trades_get(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: This can only be used in combination with symbol.
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int from_id: Trade id to fetch from. Default gets most recent trades.
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[MyTrade]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_my_trades_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_my_trades_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_my_trades_get_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Account Trade List (USER_DATA)  # noqa: E501

        Get trades for a specific account and symbol.  If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.  The time between startTime and endTime can't be longer than 24 hours. These are the supported combinations of all parameters:    symbol    symbol + orderId    symbol + startTime    symbol + endTime    symbol + fromId    symbol + startTime + endTime    symbol+ orderId + fromId  Weight(IP): 20  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_my_trades_get_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: This can only be used in combination with symbol.
        :param int start_time: UTC timestamp in ms
        :param int end_time: UTC timestamp in ms
        :param int from_id: Trade id to fetch from. Default gets most recent trades.
        :param int limit: Default 500; max 1000.
        :param int recv_window: The value cannot be greater than 60000
        :return: list[MyTrade]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'order_id', 'start_time', 'end_time', 'from_id', 'limit', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_my_trades_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_my_trades_get`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_my_trades_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_my_trades_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'start_time' in params:
            query_params.append(('startTime', params['start_time']))  # noqa: E501
        if 'end_time' in params:
            query_params.append(('endTime', params['end_time']))  # noqa: E501
        if 'from_id' in params:
            query_params.append(('fromId', params['from_id']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/myTrades', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[MyTrade]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_open_order_list_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query Open OCO (USER_DATA)  # noqa: E501

        Weight(IP): 6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_order_list_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_open_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_open_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_open_order_list_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query Open OCO (USER_DATA)  # noqa: E501

        Weight(IP): 6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_order_list_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20013]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_open_order_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_open_order_list_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_open_order_list_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/openOrderList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20013]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_open_orders_delete(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel all Open Orders on a Symbol (TRADE)  # noqa: E501

        Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_orders_delete(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_open_orders_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_open_orders_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_open_orders_delete_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel all Open Orders on a Symbol (TRADE)  # noqa: E501

        Cancels all active orders on a symbol. This includes OCO orders.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_orders_delete_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[object]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_open_orders_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_open_orders_delete`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_open_orders_delete`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_open_orders_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/openOrders', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[object]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_open_orders_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Current Open Orders (USER_DATA)  # noqa: E501

        Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_orders_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str symbol: Trading symbol, e.g. BNBUSDT
        :param int recv_window: The value cannot be greater than 60000
        :return: list[OrderDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_open_orders_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_open_orders_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_open_orders_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Current Open Orders (USER_DATA)  # noqa: E501

        Get all open orders on a symbol. Careful when accessing this with no symbol.  Weight(IP): - `6` for a single symbol; - `80` when the symbol parameter is omitted;  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_open_orders_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str symbol: Trading symbol, e.g. BNBUSDT
        :param int recv_window: The value cannot be greater than 60000
        :return: list[OrderDetails]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'symbol', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_open_orders_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_open_orders_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_open_orders_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/openOrders', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[OrderDetails]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_cancel_replace_post(self, symbol, side, type, cancel_replace_mode, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel an Existing Order and Send a New Order (Trade)  # noqa: E501

        Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_cancel_replace_post(symbol, side, type, cancel_replace_mode, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param str cancel_replace_mode: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails. (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str cancel_restrictions:
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str cancel_new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param str cancel_orig_client_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :param int cancel_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_cancel_replace_post_with_http_info(symbol, side, type, cancel_replace_mode, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_cancel_replace_post_with_http_info(symbol, side, type, cancel_replace_mode, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_cancel_replace_post_with_http_info(self, symbol, side, type, cancel_replace_mode, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel an Existing Order and Send a New Order (Trade)  # noqa: E501

        Cancels an existing order and places a new order on the same symbol.  Filters and Order Count are evaluated before the processing of the cancellation and order placement occurs.  A new order that was not attempted (i.e. when newOrderResult: NOT_ATTEMPTED), will still increase the order count by 1.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_cancel_replace_post_with_http_info(symbol, side, type, cancel_replace_mode, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param str cancel_replace_mode: - `STOP_ON_FAILURE` If the cancel request fails, the new order placement will not be attempted. - `ALLOW_FAILURES` If new order placement will be attempted even if cancel request fails. (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str cancel_restrictions:
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str cancel_new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param str cancel_orig_client_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :param int cancel_order_id: Either the cancelOrigClientOrderId or cancelOrderId must be provided. If both are provided, cancelOrderId takes precedence.
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'type', 'cancel_replace_mode', 'timestamp', 'signature', 'cancel_restrictions', 'time_in_force', 'quantity', 'quote_order_qty', 'price', 'cancel_new_client_order_id', 'cancel_orig_client_order_id', 'cancel_order_id', 'new_client_order_id', 'strategy_id', 'strategy_type', 'stop_price', 'trailing_delta', 'iceberg_qty', 'new_order_resp_type', 'self_trade_prevention_mode', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_cancel_replace_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501
        # verify the required parameter 'cancel_replace_mode' is set
        if ('cancel_replace_mode' not in params or
                params['cancel_replace_mode'] is None):
            raise ValueError("Missing the required parameter `cancel_replace_mode` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_cancel_replace_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'cancel_replace_mode' in params:
            query_params.append(('cancelReplaceMode', params['cancel_replace_mode']))  # noqa: E501
        if 'cancel_restrictions' in params:
            query_params.append(('cancelRestrictions', params['cancel_restrictions']))  # noqa: E501
        if 'time_in_force' in params:
            query_params.append(('timeInForce', params['time_in_force']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'quote_order_qty' in params:
            query_params.append(('quoteOrderQty', params['quote_order_qty']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'cancel_new_client_order_id' in params:
            query_params.append(('cancelNewClientOrderId', params['cancel_new_client_order_id']))  # noqa: E501
        if 'cancel_orig_client_order_id' in params:
            query_params.append(('cancelOrigClientOrderId', params['cancel_orig_client_order_id']))  # noqa: E501
        if 'cancel_order_id' in params:
            query_params.append(('cancelOrderId', params['cancel_order_id']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'strategy_id' in params:
            query_params.append(('strategyId', params['strategy_id']))  # noqa: E501
        if 'strategy_type' in params:
            query_params.append(('strategyType', params['strategy_type']))  # noqa: E501
        if 'stop_price' in params:
            query_params.append(('stopPrice', params['stop_price']))  # noqa: E501
        if 'trailing_delta' in params:
            query_params.append(('trailingDelta', params['trailing_delta']))  # noqa: E501
        if 'iceberg_qty' in params:
            query_params.append(('icebergQty', params['iceberg_qty']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'self_trade_prevention_mode' in params:
            query_params.append(('selfTradePreventionMode', params['self_trade_prevention_mode']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order/cancelReplace', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_delete(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel Order (TRADE)  # noqa: E501

        Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_delete(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param str orig_client_order_id: Order id from client
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param str cancel_restrictions:
        :param int recv_window: The value cannot be greater than 60000
        :return: Order
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_delete_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel Order (TRADE)  # noqa: E501

        Cancel an active order.  Either `orderId` or `origClientOrderId` must be sent.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_delete_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param str orig_client_order_id: Order id from client
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param str cancel_restrictions:
        :param int recv_window: The value cannot be greater than 60000
        :return: Order
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'order_id', 'orig_client_order_id', 'new_client_order_id', 'cancel_restrictions', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_delete`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_delete`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'orig_client_order_id' in params:
            query_params.append(('origClientOrderId', params['orig_client_order_id']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'cancel_restrictions' in params:
            query_params.append(('cancelRestrictions', params['cancel_restrictions']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Order',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_get(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Order (USER_DATA)  # noqa: E501

        Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_get(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param str orig_client_order_id: Order id from client
        :param int recv_window: The value cannot be greater than 60000
        :return: OrderDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_get_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_get_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Query Order (USER_DATA)  # noqa: E501

        Check an order's status.  - Either `orderId` or `origClientOrderId` must be sent. - For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.  Weight(IP): 4  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_get_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_id: Order id
        :param str orig_client_order_id: Order id from client
        :param int recv_window: The value cannot be greater than 60000
        :return: OrderDetails
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'order_id', 'orig_client_order_id', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_get`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'order_id' in params:
            query_params.append(('orderId', params['order_id']))  # noqa: E501
        if 'orig_client_order_id' in params:
            query_params.append(('origClientOrderId', params['orig_client_order_id']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OrderDetails',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_list_delete(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel OCO (TRADE)  # noqa: E501

        Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_list_delete(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_list_id: Order list id
        :param str list_client_order_id: A unique Id for the entire orderList
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int recv_window: The value cannot be greater than 60000
        :return: OcoOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_list_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_list_delete_with_http_info(symbol, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_list_delete_with_http_info(self, symbol, timestamp, signature, **kwargs):  # noqa: E501
        """Cancel OCO (TRADE)  # noqa: E501

        Cancel an entire Order List  Canceling an individual leg will cancel the entire OCO  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_list_delete_with_http_info(symbol, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_list_id: Order list id
        :param str list_client_order_id: A unique Id for the entire orderList
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int recv_window: The value cannot be greater than 60000
        :return: OcoOrder
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'timestamp', 'signature', 'order_list_id', 'list_client_order_id', 'new_client_order_id', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_list_delete" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_list_delete`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_list_delete`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_list_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'order_list_id' in params:
            query_params.append(('orderListId', params['order_list_id']))  # noqa: E501
        if 'list_client_order_id' in params:
            query_params.append(('listClientOrderId', params['list_client_order_id']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/orderList', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='OcoOrder',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_list_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query OCO (USER_DATA)  # noqa: E501

        Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_list_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_list_id: Order list id
        :param str orig_client_order_id: Order id from client
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_list_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_list_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query OCO (USER_DATA)  # noqa: E501

        Retrieves a specific OCO based on provided optional parameters  Weight(IP): 4  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_list_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int order_list_id: Order list id
        :param str orig_client_order_id: Order id from client
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'order_list_id', 'orig_client_order_id', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_list_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_list_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_list_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'order_list_id' in params:
            query_params.append(('orderListId', params['order_list_id']))  # noqa: E501
        if 'orig_client_order_id' in params:
            query_params.append(('origClientOrderId', params['orig_client_order_id']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/orderList', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_oco_post(self, symbol, side, quantity, price, stop_price, timestamp, signature, **kwargs):  # noqa: E501
        """New OCO (TRADE)  # noqa: E501

        Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_oco_post(symbol, side, quantity, price, stop_price, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param float quantity: (required)
        :param float price: Order price (required)
        :param float stop_price: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str list_client_order_id: A unique Id for the entire orderList
        :param str limit_client_order_id: A unique Id for the limit order
        :param int limit_strategy_id:
        :param int limit_strategy_type: The value cannot be less than 1000000.
        :param float limit_iceberg_qty:
        :param float trailing_delta:
        :param str stop_client_order_id: A unique Id for the stop loss/stop loss limit leg
        :param int stop_strategy_id:
        :param int stop_strategy_type:
        :param float stop_limit_price: If provided, stopLimitTimeInForce is required.
        :param float stop_iceberg_qty:
        :param str stop_limit_time_in_force:
        :param str new_order_resp_type: Set the response JSON.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_oco_post_with_http_info(symbol, side, quantity, price, stop_price, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_oco_post_with_http_info(symbol, side, quantity, price, stop_price, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_oco_post_with_http_info(self, symbol, side, quantity, price, stop_price, timestamp, signature, **kwargs):  # noqa: E501
        """New OCO (TRADE)  # noqa: E501

        Send in a new OCO  - Price Restrictions:   - `SELL`: Limit Price > Last Price > Stop Price   - `BUY`: Limit Price < Last Price < Stop Price - Quantity Restrictions:     - Both legs must have the same quantity     - `ICEBERG` quantities however do not have to be the same - Order Rate Limit     - `OCO` counts as 2 orders against the order rate limit.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_oco_post_with_http_info(symbol, side, quantity, price, stop_price, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param float quantity: (required)
        :param float price: Order price (required)
        :param float stop_price: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str list_client_order_id: A unique Id for the entire orderList
        :param str limit_client_order_id: A unique Id for the limit order
        :param int limit_strategy_id:
        :param int limit_strategy_type: The value cannot be less than 1000000.
        :param float limit_iceberg_qty:
        :param float trailing_delta:
        :param str stop_client_order_id: A unique Id for the stop loss/stop loss limit leg
        :param int stop_strategy_id:
        :param int stop_strategy_type:
        :param float stop_limit_price: If provided, stopLimitTimeInForce is required.
        :param float stop_iceberg_qty:
        :param str stop_limit_time_in_force:
        :param str new_order_resp_type: Set the response JSON.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'quantity', 'price', 'stop_price', 'timestamp', 'signature', 'list_client_order_id', 'limit_client_order_id', 'limit_strategy_id', 'limit_strategy_type', 'limit_iceberg_qty', 'trailing_delta', 'stop_client_order_id', 'stop_strategy_id', 'stop_strategy_type', 'stop_limit_price', 'stop_iceberg_qty', 'stop_limit_time_in_force', 'new_order_resp_type', 'self_trade_prevention_mode', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_oco_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if ('quantity' not in params or
                params['quantity'] is None):
            raise ValueError("Missing the required parameter `quantity` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'price' is set
        if ('price' not in params or
                params['price'] is None):
            raise ValueError("Missing the required parameter `price` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'stop_price' is set
        if ('stop_price' not in params or
                params['stop_price'] is None):
            raise ValueError("Missing the required parameter `stop_price` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_oco_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_oco_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'list_client_order_id' in params:
            query_params.append(('listClientOrderId', params['list_client_order_id']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'limit_client_order_id' in params:
            query_params.append(('limitClientOrderId', params['limit_client_order_id']))  # noqa: E501
        if 'limit_strategy_id' in params:
            query_params.append(('limitStrategyId', params['limit_strategy_id']))  # noqa: E501
        if 'limit_strategy_type' in params:
            query_params.append(('limitStrategyType', params['limit_strategy_type']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'limit_iceberg_qty' in params:
            query_params.append(('limitIcebergQty', params['limit_iceberg_qty']))  # noqa: E501
        if 'trailing_delta' in params:
            query_params.append(('trailingDelta', params['trailing_delta']))  # noqa: E501
        if 'stop_client_order_id' in params:
            query_params.append(('stopClientOrderId', params['stop_client_order_id']))  # noqa: E501
        if 'stop_price' in params:
            query_params.append(('stopPrice', params['stop_price']))  # noqa: E501
        if 'stop_strategy_id' in params:
            query_params.append(('stopStrategyId', params['stop_strategy_id']))  # noqa: E501
        if 'stop_strategy_type' in params:
            query_params.append(('stopStrategyType', params['stop_strategy_type']))  # noqa: E501
        if 'stop_limit_price' in params:
            query_params.append(('stopLimitPrice', params['stop_limit_price']))  # noqa: E501
        if 'stop_iceberg_qty' in params:
            query_params.append(('stopIcebergQty', params['stop_iceberg_qty']))  # noqa: E501
        if 'stop_limit_time_in_force' in params:
            query_params.append(('stopLimitTimeInForce', params['stop_limit_time_in_force']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'self_trade_prevention_mode' in params:
            query_params.append(('selfTradePreventionMode', params['self_trade_prevention_mode']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order/oco', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_post(self, symbol, side, type, timestamp, signature, **kwargs):  # noqa: E501
        """New Order (TRADE)  # noqa: E501

        Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_post(symbol, side, type, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_post_with_http_info(symbol, side, type, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_post_with_http_info(symbol, side, type, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_post_with_http_info(self, symbol, side, type, timestamp, signature, **kwargs):  # noqa: E501
        """New Order (TRADE)  # noqa: E501

        Send in a new order.  - `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker. - `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached. - Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`. - Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`. - `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price. - `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`. - `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`. - same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.  Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:  - Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL` - Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`   Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_post_with_http_info(symbol, side, type, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'type', 'timestamp', 'signature', 'time_in_force', 'quantity', 'quote_order_qty', 'price', 'new_client_order_id', 'strategy_id', 'strategy_type', 'stop_price', 'trailing_delta', 'iceberg_qty', 'new_order_resp_type', 'self_trade_prevention_mode', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_order_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `api_v3_order_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'time_in_force' in params:
            query_params.append(('timeInForce', params['time_in_force']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'quote_order_qty' in params:
            query_params.append(('quoteOrderQty', params['quote_order_qty']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'strategy_id' in params:
            query_params.append(('strategyId', params['strategy_id']))  # noqa: E501
        if 'strategy_type' in params:
            query_params.append(('strategyType', params['strategy_type']))  # noqa: E501
        if 'stop_price' in params:
            query_params.append(('stopPrice', params['stop_price']))  # noqa: E501
        if 'trailing_delta' in params:
            query_params.append(('trailingDelta', params['trailing_delta']))  # noqa: E501
        if 'iceberg_qty' in params:
            query_params.append(('icebergQty', params['iceberg_qty']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'self_trade_prevention_mode' in params:
            query_params.append(('selfTradePreventionMode', params['self_trade_prevention_mode']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_order_test_post(self, symbol, side, type, timestamp, signature, **kwargs):  # noqa: E501
        """Test New Order (TRADE)  # noqa: E501

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_test_post(symbol, side, type, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param int recv_window: The value cannot be greater than 60000
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_order_test_post_with_http_info(symbol, side, type, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_order_test_post_with_http_info(symbol, side, type, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_order_test_post_with_http_info(self, symbol, side, type, timestamp, signature, **kwargs):  # noqa: E501
        """Test New Order (TRADE)  # noqa: E501

        Test new order creation and signature/recvWindow long. Creates and validates a new order but does not send it into the matching engine.  Weight(IP): 1  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_order_test_post_with_http_info(symbol, side, type, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float quantity: Order quantity
        :param float quote_order_qty: Quote quantity
        :param float price: Order price
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float stop_price: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float trailing_delta: Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param int recv_window: The value cannot be greater than 60000
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'type', 'timestamp', 'signature', 'time_in_force', 'quantity', 'quote_order_qty', 'price', 'new_client_order_id', 'strategy_id', 'strategy_type', 'stop_price', 'trailing_delta', 'iceberg_qty', 'new_order_resp_type', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_order_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_order_test_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_order_test_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `api_v3_order_test_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_order_test_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_order_test_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'time_in_force' in params:
            query_params.append(('timeInForce', params['time_in_force']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'quote_order_qty' in params:
            query_params.append(('quoteOrderQty', params['quote_order_qty']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'strategy_id' in params:
            query_params.append(('strategyId', params['strategy_id']))  # noqa: E501
        if 'strategy_type' in params:
            query_params.append(('strategyType', params['strategy_type']))  # noqa: E501
        if 'stop_price' in params:
            query_params.append(('stopPrice', params['stop_price']))  # noqa: E501
        if 'trailing_delta' in params:
            query_params.append(('trailingDelta', params['trailing_delta']))  # noqa: E501
        if 'iceberg_qty' in params:
            query_params.append(('icebergQty', params['iceberg_qty']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/order/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_rate_limit_order_get(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query Current Order Count Usage (TRADE)  # noqa: E501

        Displays the user's current order count usage for all intervals.  Weight(IP): 40  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_rate_limit_order_get(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20015]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_rate_limit_order_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_rate_limit_order_get_with_http_info(timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_rate_limit_order_get_with_http_info(self, timestamp, signature, **kwargs):  # noqa: E501
        """Query Current Order Count Usage (TRADE)  # noqa: E501

        Displays the user's current order count usage for all intervals.  Weight(IP): 40  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_rate_limit_order_get_with_http_info(timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param int recv_window: The value cannot be greater than 60000
        :return: list[InlineResponse20015]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['timestamp', 'signature', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_rate_limit_order_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_rate_limit_order_get`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_rate_limit_order_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/rateLimit/order', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[InlineResponse20015]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_sor_order_post(self, symbol, side, type, quantity, timestamp, signature, **kwargs):  # noqa: E501
        """New order using SOR (TRADE)  # noqa: E501

        Weight(IP): 6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_sor_order_post(symbol, side, type, quantity, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param float quantity: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float price:
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_sor_order_post_with_http_info(symbol, side, type, quantity, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_sor_order_post_with_http_info(symbol, side, type, quantity, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_sor_order_post_with_http_info(self, symbol, side, type, quantity, timestamp, signature, **kwargs):  # noqa: E501
        """New order using SOR (TRADE)  # noqa: E501

        Weight(IP): 6  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_sor_order_post_with_http_info(symbol, side, type, quantity, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param float quantity: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float price:
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'type', 'quantity', 'timestamp', 'signature', 'time_in_force', 'price', 'new_client_order_id', 'strategy_id', 'strategy_type', 'iceberg_qty', 'new_order_resp_type', 'self_trade_prevention_mode', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_sor_order_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_sor_order_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_sor_order_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `api_v3_sor_order_post`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if ('quantity' not in params or
                params['quantity'] is None):
            raise ValueError("Missing the required parameter `quantity` when calling `api_v3_sor_order_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_sor_order_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_sor_order_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'time_in_force' in params:
            query_params.append(('timeInForce', params['time_in_force']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'strategy_id' in params:
            query_params.append(('strategyId', params['strategy_id']))  # noqa: E501
        if 'strategy_type' in params:
            query_params.append(('strategyType', params['strategy_type']))  # noqa: E501
        if 'iceberg_qty' in params:
            query_params.append(('icebergQty', params['iceberg_qty']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'self_trade_prevention_mode' in params:
            query_params.append(('selfTradePreventionMode', params['self_trade_prevention_mode']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/sor/order', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def api_v3_sor_order_test_post(self, symbol, side, type, quantity, timestamp, signature, **kwargs):  # noqa: E501
        """Test new order using SOR (TRADE)  # noqa: E501

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_sor_order_test_post(symbol, side, type, quantity, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param float quantity: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float price:
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.api_v3_sor_order_test_post_with_http_info(symbol, side, type, quantity, timestamp, signature, **kwargs)  # noqa: E501
        else:
            (data) = self.api_v3_sor_order_test_post_with_http_info(symbol, side, type, quantity, timestamp, signature, **kwargs)  # noqa: E501
            return data

    def api_v3_sor_order_test_post_with_http_info(self, symbol, side, type, quantity, timestamp, signature, **kwargs):  # noqa: E501
        """Test new order using SOR (TRADE)  # noqa: E501

        Test new order creation and signature/recvWindow using smart order routing (SOR). Creates and validates a new order but does not send it into the matching engine.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.api_v3_sor_order_test_post_with_http_info(symbol, side, type, quantity, timestamp, signature, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str symbol: Trading symbol, e.g. BNBUSDT (required)
        :param str side: (required)
        :param str type: Order type (required)
        :param float quantity: (required)
        :param int timestamp: UTC timestamp in ms (required)
        :param str signature: Signature (required)
        :param str time_in_force: Order time in force
        :param float price:
        :param str new_client_order_id: Used to uniquely identify this cancel. Automatically generated by default
        :param int strategy_id:
        :param int strategy_type: The value cannot be less than 1000000.
        :param float iceberg_qty: Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
        :param str new_order_resp_type: Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
        :param str self_trade_prevention_mode: The allowed enums is dependent on what is configured on the symbol. The possible supported values are EXPIRE_TAKER, EXPIRE_MAKER, EXPIRE_BOTH, NONE.
        :param int recv_window: The value cannot be greater than 60000
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['symbol', 'side', 'type', 'quantity', 'timestamp', 'signature', 'time_in_force', 'price', 'new_client_order_id', 'strategy_id', 'strategy_type', 'iceberg_qty', 'new_order_resp_type', 'self_trade_prevention_mode', 'recv_window']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method api_v3_sor_order_test_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'symbol' is set
        if ('symbol' not in params or
                params['symbol'] is None):
            raise ValueError("Missing the required parameter `symbol` when calling `api_v3_sor_order_test_post`")  # noqa: E501
        # verify the required parameter 'side' is set
        if ('side' not in params or
                params['side'] is None):
            raise ValueError("Missing the required parameter `side` when calling `api_v3_sor_order_test_post`")  # noqa: E501
        # verify the required parameter 'type' is set
        if ('type' not in params or
                params['type'] is None):
            raise ValueError("Missing the required parameter `type` when calling `api_v3_sor_order_test_post`")  # noqa: E501
        # verify the required parameter 'quantity' is set
        if ('quantity' not in params or
                params['quantity'] is None):
            raise ValueError("Missing the required parameter `quantity` when calling `api_v3_sor_order_test_post`")  # noqa: E501
        # verify the required parameter 'timestamp' is set
        if ('timestamp' not in params or
                params['timestamp'] is None):
            raise ValueError("Missing the required parameter `timestamp` when calling `api_v3_sor_order_test_post`")  # noqa: E501
        # verify the required parameter 'signature' is set
        if ('signature' not in params or
                params['signature'] is None):
            raise ValueError("Missing the required parameter `signature` when calling `api_v3_sor_order_test_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'symbol' in params:
            query_params.append(('symbol', params['symbol']))  # noqa: E501
        if 'side' in params:
            query_params.append(('side', params['side']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'time_in_force' in params:
            query_params.append(('timeInForce', params['time_in_force']))  # noqa: E501
        if 'quantity' in params:
            query_params.append(('quantity', params['quantity']))  # noqa: E501
        if 'price' in params:
            query_params.append(('price', params['price']))  # noqa: E501
        if 'new_client_order_id' in params:
            query_params.append(('newClientOrderId', params['new_client_order_id']))  # noqa: E501
        if 'strategy_id' in params:
            query_params.append(('strategyId', params['strategy_id']))  # noqa: E501
        if 'strategy_type' in params:
            query_params.append(('strategyType', params['strategy_type']))  # noqa: E501
        if 'iceberg_qty' in params:
            query_params.append(('icebergQty', params['iceberg_qty']))  # noqa: E501
        if 'new_order_resp_type' in params:
            query_params.append(('newOrderRespType', params['new_order_resp_type']))  # noqa: E501
        if 'self_trade_prevention_mode' in params:
            query_params.append(('selfTradePreventionMode', params['self_trade_prevention_mode']))  # noqa: E501
        if 'recv_window' in params:
            query_params.append(('recvWindow', params['recv_window']))  # noqa: E501
        if 'timestamp' in params:
            query_params.append(('timestamp', params['timestamp']))  # noqa: E501
        if 'signature' in params:
            query_params.append(('signature', params['signature']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['ApiKeyAuth']  # noqa: E501

        return self.api_client.call_api(
            '/api/v3/sor/order/test', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
